# Google C++ Style Guide

## Заголовочные файлы

Обычно каждый .cc файл должен иметь ассоциированный с ним .h файл.Существует несколько распространенных исключений, таких как юнит-тесты или небольшие .cc файлы, содержащие только функцию main().
Правильное использование заголовочных файлов может значительно улучшить читабельность, уменьшить размер и повысить производительность вашего кода.
Следующие правила помогут вам избежать множество ловушек при использовании заголовочных файлов.

### Предохранитель #define 

Все заголовочные файлы должны иметь предохранитель #define, для того чтобы избежать множественного включения.Формат имени должен быть: *<ПРОЕКТ>\_<ПУТЬ>\_<ФАЙЛ>\_H\_.*

Для того чтобы гарантировать уникальность, они должны быть основаны на полном пути внутри проекта.Например, файл *foo/src/bar/baz.h* в проекте foo должен иметь следующий предохранитель:

``` cpp
#ifndef FOO_BAR_BAZ_H_

#define FOO_BAR_BAZ_H_

... 

#endif // FOO_BAR_BAZ_H_
```

### Зависимости заголовочных файлов

Не используйте *#include*, когда достаточно предварительного объявления.

Включая заголовочный файл, вы вносите зависимость, из-за которой ваш код вынужден будет компилироваться всякий раз, когда заголовочный файл изменился.Если ваш заголовочный файл включает в себя другие заголовочные файлы, тогда любое изменение в этих файлах потребует перекомпиляции любого кода, включающего ваш заголовочный файл.Поэтому мы предпочитаем минимизировать включения, в особенности включения заголовочных файлов в другие заголовочные файлы.

Вы можете значительно минимизировать число включаемых заголовочных файлов, используя предварительные объявления.Например, если ваш заголовочный файл использует класс *File* способом, не требующим доступа к объявлению класса *File*, тогда ваш заголовочный файл может просто предварительно объявить класс *File*, вместо включения *#include "file/base/file.h"*.

Как мы можем использовать класс *Foo* в заголовочном файле без доступа к его определению?

* Мы можем объявить член данных типа *Foo** или *Foo&*.
* Мы можем объявить (но не определить) функции с аргументами и/или возвращаемым значением типа *Foo*.
* Мы можем объявить статические члены данных типа *Foo*.Это возможно, благодаря тому что статические члены данных определяются вне определения класса.

С другой стороны, вы обязаны включать заголовочный файл для *Foo*, если вы наследуете свой класс от *Foo* или есть член данных типа *Foo*.

Разумеется, .cc файлы обычно требуют включения определений используемых классов и, как правило, должны включать несколько заголовочных файлов.

### Встроенные функции

Определяйте встроенные функции только когда они маленькие, скажем, 10 строк или меньше.

#### Определение:

Вы можете объявить функции таким образом, что компилятор подключит их напрямую, вместо использования обычного механизма вызова функций.

#### Доводы за:

Встроенные функции могут создавать более эффективный объектный код, если таковая функция небольшая.Без колебаний встраивайте функции доступа и мутаторы, а также другие короткие, критичные для производительности функции.

#### Доводы против:

Чрезмерное использование встроенных функций может на самом деле сделать программы медленней.В зависимости от размера функции ее встраивание может как увеличить, так и уменьшить размер программы.Встраивание очень короткой функции доступа обычно уменьшает размер программы, в то время как встраивание очень большой функции может значительно увеличить его.На современных процессорах более маленький код обычно исполняется быстрее из-за лучшего использования командного кэша.

#### Решение:

Разумным правилом является не использовать *inline* для функций размером более 10 строк.Остерегайтесь деструкторов, поскольку их код больше, чем кажется, из-за неявных вызовов деструкторов для членов класса и базового класса.

Другое полезное правило: обычно не является эффективным включение функций с циклом или *switch* внутри (за исключение общих случаев, когда ни цикл, ни *switch* ни разу не выполняются).

Важно понимать, что объявление функции *inline* не гарантирует того, что она будет использоваться как встроенная; например, виртуальные или рекурсивные функции обычно не встраиваются.Как правило, рекурсивные функции не должны быть *inline*.Основной причиной для объявления виртуальной функции *inline* является желание поместить ее определение внутри класса либо из-за удобства, либо для документирования ее поведения, как в случае с функциями доступа или мутаторами.

### Порядок параметров в функции

В определении функции используется следующий порядок параметров: входные, затем выходные.

Параметры функций в C/C++ являются либо входными данными, либо выходными, либо обоими одновременно.Входные параметры обычно либо значения, либо константные ссылки, в то время как выходные параметры являются неконстантными указателями.Задавая порядок параметров, располагайте входные параметры перед выходными.Никогда не добавляйте новые параметры в конец только потому, что они новые, размещайте новые входные параметры перед выходными параметрами.

Это правило не является неукоснительным.Одновременно и входные и выходные параметры (часто классы или структуры) мутят воду, и, как всегда, согласованность со связанными функциями может потребовать от вас нарушения правил.

### Имена и порядок включений

Используйте стандартный порядок для читабельности и избегайте скрытых зависимостей: библиотеки C, библиотеки C++, .h файлы других библиотек, .h файлы вашего проекта.

Все заголовочные файлы проекта должны быть указаны как потомки директории с исходниками проекта без использования UNIX шорткатов .(текущая директория) или ..(родительская директория).Например, *google-awesome-project/src/base/logging.h* следует включать как 

`#include "base/logging.h"` 

В *dir/foo.cc*, чьей основной задачей является реализация или тестирование определенного в *dir2/foo2.h*, разместите ваши включения следующим образом:

* *dir2/foo2.h* (предпочтительное размещение - детали см.ниже).
* Пустая строка
* Системные файлы C.
* Пустая строка
* Системные файлы C++.
* .h файлы других библиотек.
* .h файлы вашего проекта.

Этот порядок уменьшает скрытые зависимости.Мы хотим, чтобы каждый заголовочный файл компилировался независимо.Простейший способ этого добиться - убедиться в том, что каждый из них является первым .h файлом, включенным в соответствующий .cc файл.

*dir/foo.cc* и *dir2/foo2.h* зачастую расположены в одной директории (например *base/basictypes_unittest.cc* и *base/basictypes.h*), но могут быть также и в разных директориях.

Внутри каждой секции хорошо бы располагать включения в алфавитном порядке.

Вы должны включить все заголовки, которые определяют символы, на которые вы полагаетесь, за исключением необычного случая предварительного объявления.Если вы полагаетесь на символы из bar.h, не рассчитывайте на тот факт, что вы включили, foo.hкоторый (в настоящее время) включает в себя bar.h: включить bar.h себя, если foo.h явно не демонстрирует свое намерение предоставить вам символы bar.h.

К примеру, включения в *google-awesome-project/src/foo/internal/fooserver.cc* могут выглядеть следующим образом:

``` cpp
#include "foo/public/fooserver.h" // Предпочтительное размещение.

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

## Ограничения области видимости

### Пространства имен

Неименованные пространства имен в .сс поощряются.Для именованных выбирайте имена, основанные на проекте, и, возможно, его пути.Не используйте директиву *using*.

#### Определение:

Пространства имен разделяют глобальную область видимости на отдельные, именованные области видимости, и, таким образом, полезны для предотвращения конфликта имен.

#### Плюсы:

Пространства имен предоставляют (иерархическую) ось именования в дополнение к (также иерархической) именной оси, предоставляемой классами.

Например, если два различных проекта имеют класс *Foo* в глобальном пространстве имен, тогда эти символы могут конфликтовать во время компиляции или во время исполнения.Если каждый проект расположит свой код в собственном пространстве имен, то *project1:: Foo* и *project2:: Foo* будут различны и не вызовут конфликта.

#### Минусы:

Пространства имен могут запутывать код, поскольку они предоставляют дополнительную (иерархическую) ось имен, в добавление к (также иерархической) оси имен, предоставляемой классами.

Использование неименованных пространств в заголовочном файле может легко вызвать нарушение Правила Одного Определения (One Definition Rule - ODR) в С++.

``` cpp
namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
```

#### Решение:

Используйте пространства имен согласно описанным ниже принципам.

**Неименованные пространства имен**

Неименованные пространства имен разрешаются и даже поощряются в .сс файлах для избежания конфликтов имен во время выполнения:

``` cpp
namespace { // Это внутри .cc файла.
// Содержимое пространства имен не имеет отступов
enum { kUnused, kEOF, kError }; // Общие используемые символы.
bool AtEof() { return pos_ == kEOF; } // Uses our namespace's EOF.
} // namespace
```

Впрочем, объявленния в области видимости файла, которые относятся к определенному классу, могут быть объявлены в этом классе как типы, статические данные или статические функции, нежели как члены неименованного пространства имен.Заканчивайте неименованное пространство имен как показано комментарием *// namespace*.

Не используйте неименованные пространства имен в .h файлах.

**Именованные пространства имен.**

Именованные пространства имен должны использоваться следующим образом:

Пространство имен охватывает весь код сразу за включениями, gflags определениями\объявлениями и предварительными объявлениями классов из других пространств имен:

``` cpp
// In the .h file
namespace mynamespace {
// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
 ... 
 void Foo(); 
}; 

} // namespace mynamespace
```

``` cpp
// In the .cc file
namespace mynamespace {
// Definition of functions is within scope of the namespace.
void MyClass:: Foo() {
... 
}

} // namespace mynamespace
```

Типичный .сс файл может содержать больше деталей, включая необходимость ссылаться на классы из других именных пространств.

``` cpp
#include "a.h"

DEFINE_bool(someflag, false, "dummy flag"); 

class C; // Прототип класса C в глобальном пространстве имен.

namespace a { class A; } // Притотип a:: A.

namespace b {
... code for b... // Код идет по левому краю.
} // пространство имен b
```

Не объявляйте ничего в пространстве *std*, включая даже предварительные объявления из стандартной библиотеки классов.Объявление сущностей и пространстве имен *std* неопределенно и потому не портабельно.Для объявления сущностей из стандартной библиотеки классов подключите соответсвующий заголовочный файл.

Вы не можете использовать директиву *using* для того, чтобы дать доступ ко всем именам из пространства имен.

``` cpp
// Запрещено - это загрязняет пространство имен.
using namespace foo; 
```

Допустимо использовать директиву *using* где угодно в .сс файле, а также в методах, функциях или классах в .h файлах.

``` cpp
// OK в.cc files.
// Должно быть внутри функции, метода или класса в .h файле.
using ::foo::bar; 
```

Псевдонимы пространств имен допустимы везде в .сс файле, а также в функциях и методах .h файлов.

``` cpp
// OK в.cc files.
// Должно быть внутри функции или метода .h файлов.
namespace fbz = ::foo::bar::baz; 
```

###  Вложенные классы.

Хотя вы можете использовать публичные вложенные классы, когда они являются частью интерфейса, рассматривайте использование пространства имен для того, чтобы держать объявления вне глобальной области видимости.

#### Определение: 

Класс может содержать определение другого класса внутри себя, называемого внутренним классом.

``` cpp
class Foo {
 private:
  // Bar — это член класса, вложенный в Foo
  class Bar {
  ... 
  }; 
}; 
```

#### Плюсы:

Полезно, когда вложенный (или внутренний) класс используется только внешним классом; создавая класс внутренним мы помещаем его в область видимости включающего класса не засоряя тем самым внешнюю область видимости именем внутреннего класса.Вложенные классы могут быть предварительно описаны внутри внешнего класса и затем определены в .сс файле во избежание полного определения вложенного класса в заголовке.Это имеет смысл делать, поскольку обычно описание внутреннего класса интересно только для реализации внешнего класса.

#### Минусы:

Вложенные классы могут быть предварительно описаны только внутри определения внешнего класса.Таким образом любой заголовочный файл использующий указатель *Foo:: Bar** должен будет включить полное определение класса Foo.

#### Решение:

Не создавайте вложенные классы публичными, за исключением случаев, когда они являются частью интерфейса, например, класс хранящий набор режимов метода.

### Внешние функции, статические методы и глобальные функции.

Предпочитайте внешние функции внутри пространства имен или статические методы глобальным функциям.Редко используйте глобальные функции.

#### Плюсы: 

Внешние функции и статические методы могут быть полезными в некоторых ситуациях.Помещение внешних функций в пространство имен помогает избежать засорения глобального пространства имен.

#### Минусы:

Внешние методы и статические методы имеет смысл использовать как члены нового класса, в особенности если они используют внешние ресурсы или имеют значительные зависимости.

#### Решение:

Иногда полезно, а порой и необходимо, определить функцию не связанную с экземпляром класса.Такая функция может быть либо статическим методом либо внешней функцией.Внешние функции не должны зависеть от внешних переменных и почти всегда должны находиться в пространстве имен.Используйте пространство имен вместо создания классов группирующих статические методы, не использующие разделяемые статические данные.

Функции определенные в той же единице компиляции, что и результирующие классы могут внести дополнительные связи и зависимости во время линковки в случае, если напрямую вызываются из других единиц компиляции.Статические методы в особенности чувствительны к этому.Рассмотрите вариант извлечения их в новый класс или размещения функций в пространстве имен возможно в отдельной библиотеки.

Если вы определяете внешнюю функцию и она требуется только в собственном .сс файле используйте неименованное пространство имен или статическую линковку (напр.*static int Foo() {... }*) для ограничения ее области видимости.

### Локальные переменные

Размещайте переменные функции в минимальной области видимости и инициализируйте их во время объявления.

С++ позволяет объявлять переменные в любом месте функции.Мы предлагаем объявлять их в наиболее локальной области видимости из возможных и наиболее близко к месту использования.Это упрощает читателю поиск объявления с тем, чтобы увидеть тип переменной и чем она была инициализирована.В особенности инициализация должна быть использована вместо объявления с последующим присвоением, например:

``` cpp
int i; 
i = f(); // Плохо: инициализация отделена от объявления.
```

``` cpp
int j = g(); // Хорошо - объявление инициализирует переменную.
```

Обращаем внимание, что gcc реализует `for (int i = 0; i < 10; ++i)` корректно (область видимости i ограничена областью видимости цикла), так что вы можете использовать i в другом цикле той же области видимости.Таким же образом корректно определяются области видимости для объявлений в if и while выражениях, например:

```cpp 
while (const char* p = strchr(str, '/')) str = p + 1; 

``` 

#### Здесь только одно предостережение:

Eсли переменная является объектом, тогда его конструктор вызывается каждый раз при входе в область видимости при создании объекта, а его деструктор на выходе.

``` cpp
// Неэффективная реализация:
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // Конструктор и деструктор будут вызваны 1000000 раз.
  f.DoSomething(i);
}
```

Может быть более эффективным объявлять подобные переменные используемые в цикле снаружи этого цикла:

``` cpp
Foo f;  // Конструктор и деструктор вызываются один раз.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

### Статические и глобальные переменные

Запрещены статические или глобальные объекты класса - они вызывают трудно находимые ошибки из-за неопределенного порядка вызова конструкторов и деструкторов.

Объекты со статическим временем жизни, включая глобальные переменные, статические переменные, статические члены класса и статические переменные функций должны быть примитивными данными: только *int*, *char*, *float*, *void*, а также их массивы или структуры из них.Статические переменные нельзя инициализировать результатом функции.Не константные статические переменные нельзя использовать в многопоточном коде.

С++ лишь частично определяет порядок с которым вызываются конструкторы, деструкторы и инициализаторы статических переменных и может меняться от версии к версии, зачастую являясь причиной трудно уловимых ошибок.Например, статическая переменная может быть уничтожена в конце программы, но все еще исполняемый код (возможно в другом потоке) все еще пытается ее использовать и терпит провал.

Поэтому мы позволяем статическим переменным содержать только примитивные данные.Это правило полностью запрещает использование в качестве статических переменных или их частей *vector* (используйте массивы С вместо них), *string* (используйте *const char\*)* или чего бы то ни было, содержащего или указывающего на объект класса.По тем же причинам мы запрещаем инициализацию статических переменных результатами вызова функций.

Если вам необходима статическая или глобальная переменная класса рассмотрите вариант инициализации указателя в функции *main()* или *pthread_once()*, которые никогда не освобождается.

#### Решение об уничтожении

Когда деструкторы тривиальны, их выполнение вообще не подлежит упорядочению (они фактически не «запускаются»), в противном случае мы подвергаемся риску доступа к объектам после окончания срока их службы.Поэтому мы разрешаем объекты со статической продолжительностью хранения, только если они тривиально разрушаемы.Фундаментальные типы (такие как указатели и *int*) являются тривиально разрушаемыми, как и массивы тривиально разрушаемых типов.Обратите внимание, что переменные, помеченные *constexpr*, тривиально разрушаемы.

``` cpp
const int kNum = 10; // разрешено 

struct X {int n; }; 
const X kX [] = {{1}, {2}, {3}}; // позволено 

void foo () { 
  static const char * const kMessages [] = {"hello", "world"}; // позволено 
} 

// разрешено: constexpr гарантирует тривиальный деструктор 
constexpr std :: array <int, 3> kArray = {{1, 2, 3}};
```

``` cpp
// плохо: нетривиальный деструктор 
const std :: string kFoo = "foo"; 

// плохо по той же причине, хотя kBar является ссылкой (правило также 
// применяется к временным объектам с увеличенным временем жизни) 
const std :: string &kBar = StrCat ("a", "b", "c"); 

void bar () { 
  // bad: нетривиальный деструктор 
  static std :: map <int, int> kData = {{1, 0}, {2, 0}, {3, 0}}; 
}
```

Обратите внимание, что ссылки не являются объектами, и, следовательно, на них не распространяются ограничения на разрушаемость.Ограничение на динамическую инициализацию все еще применяется, хотя.В частности, `static T& t = *new T;` допускается локальная статическая ссылка на функцию в форме.

#### Решение об инициализации

Инициализация - более сложная тема.Это связано с тем, что мы должны не только учитывать, выполняются ли конструкторы классов, но и учитывать оценку инициализатора:

``` cpp
int n = 5; // отлично 
int m = f (); //? (зависит от f) 
Foo x; //? (зависит от Foo :: Foo) 
Bar y = g (); //? (зависит от g и от Bar :: Bar)
```

Все, кроме первого утверждения, подвергают нас неопределенному порядку инициализации.

Концепция, которую мы ищем, называется постоянной инициализацией в формальном языке стандарта C++.Это означает, что инициализирующее выражение является константным выражением, и если объект инициализируется вызовом конструктора, конструктор также должен быть указан как *constexpr*:

``` cpp
struct Foo {constexpr Foo (int) {}}; 

int n = 5; // отлично, 5 - константное выражение 
Foo x (2); // отлично, 2 - константное выражение, а выбранный конструктор - constexpr 
Foo a [] = {Foo (1), Foo (2), Foo (3)}; // отлично
```

Постоянная инициализация всегда разрешена.Постоянная инициализация статических переменных продолжительного хранения должна быть помечена *constexpr* или, по возможности, атрибутом.Предполагается, что любая нелокальная переменная длительного статического хранения, которая не помечена таким образом, должна иметь динамическую инициализацию и проверяться это очень внимательно. ABSL_CONST_INIT

Напротив, следующие инициализации проблематичны:

``` cpp
// Некоторые объявления, используемые ниже.
time_t time (time_t *); // не constexpr! 
int f (); // не constexpr! 
struct Bar {Bar () {}}; 

// Проблемные инициализации.
time_t m = time(nullptr); // инициализация выражения не является константным выражением 
Foo y (f ()); // То же самое 
Bar b; // выбранный конструктор Bar :: Bar () not constexpr
```

Динамическая инициализация нелокальных переменных не рекомендуется, и в целом это запрещено.Однако мы разрешаем это, если ни один аспект программы не зависит от последовательности этой инициализации по отношению ко всем другим инициализациям.При этих ограничениях порядок инициализации не имеет заметного различия.Например:

``` cpp
int p = getpid (); // разрешено, если никакая другая статическая переменная 
                   // не использует p в своей собственной инициализаци
```

Динамическая инициализация статических локальных переменных разрешена (и распространена).

## Классы

Классы являются фундаментальной единицей программирования на С++.Естественно они широко применяются.В данном разделе мы перечисляем основные "можно" и "нельзя" при написании класса.

### Выполнение работ в конструкторах.

Выполняйте только тривиальные инициализации в конструкторе.Если это возможно используйте метод Init() для не тривиальной инициализации.

#### Определение:

Выполнение инициализации в теле конструктора возможно.

#### Плюсы:

Удобство в наборе.Не нужно беспокоится о том, был ли класс инициализирован или нет.

#### Минусы: 

Проблемы выполнения работ в конструкторах следующие:

* Не существует простого способа сигнализации ошибок в конструкторе, невозможность использования исключений (которые запрещены).

* В случае ошибки мы получаем объект, чей код инициализации потерпел неудачу и таким образом он может находиться в неопределенном состоянии.

* Если код вызывает виртуальные функции, то эти вызовы не используют реализации классов наследников.Будущие модификации вашего класса могут незаметно столкнуться с этой проблемой, вызывая значительную неразбериху, даже если на данный момент ваш класс не имеет наследников.

* Если кто-то создаст глобальную переменную этого типа (что является нарушением правил, но все же), код конструктора будет вызван перед функцией main() с вероятным нарушением некоторых неявных допущений в коде конструктора.К примеру, gflags не будет еще инициализирован.

#### Решение:

Если ваш объект требует не тривиальной инициализации рассмотрите вариант использования явного метода Init() либо добавление флага сигнализирующего о том, что объект был успешно инициализирован.

### Конструкторы по умолчанию.

Вы должны определить конструктор по умолчанию если ваш класс содержит другие переменные и не имеет других конструкторов.В противном случае компилятор сделает это за вас, но плохо.

#### Определение: 

Конструктор по умолчанию вызывается, когда мы создаем новый объект класса без аргументов.Он всегда вызывается при использовании *new[]* (для массивов).

#### Плюсы: 

Инициализируя структуры по умолчанию "невозможными" значениями значительно упрощает отладку.

#### Минусы:

Больше работы для вас, пишущего код.

#### Решение:

Если ваш класс содержащий члены данных и не имеет других конструкторов, тогда вы должны определить конструктор по умолчанию (без аргументов).В нем желательно инициализировать объект таким образом, чтобы его внутреннее состояние было последовательным и валидным.

Причиной тому служит то, что если вы не определите конструктор по умолчанию, тогда компилятор сделает это за вас.Этот сгенерированный компилятором конструктор возможно не инициализирует ваш объект как вы того ждете.

Если ваш класс наследует от существующего класса и при этом не добавляет новые члены данных, тогда вы не обязаны иметь конструктор по умолчанию.

``` cpp
class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
```

``` cpp
Func({42, 3.14}); // Ошибка
```

### Явные конструкторы

Используйте ключевое слово С++ *explicit* для конструкторов с одним аргументом.

#### Определение:

Обычно, если конструктор принимает один аргумент, он может быть использован в преобразованиях.К примеру, если вы определили *Foo:: Foo(string name)* и затем передали *string* в функцию ожидающую *Foo*, указанный ранее конструктор будет вызван для преобразования *string* в *Foo* и передачи *Foo* в вашу функцию.Это может быть удобно, но это также является источником проблем, когда конвертация происходит и объекты создаются не там, где вы ожидали.Объявление конструктора *explicit* запрещает его использование в неявных преобразованиях.

#### Плюсы:

Избегаем нежелательные преобразования.

#### Минусы: 

Нет.

#### Решение:

Мы требуем, чтобы все конструкторы с одним аргументом были явными.Всегда размещайте *explicit* перед в начале таких конструкторов в определении класса: *explicit Foo(string name)*.

Исключение составляет конструкторы копирования, которые, в редких случаях когда мы позволяем их, не должны быть явными.Также исключение составляют классы предназначенные быть незаметной оболочкой вокруг других классов.Подобные исключения должны быть четко обозначены в комментариях.

### Конструкторы копирования

Используйте конструкторы копирования только когда вашему коду нужно копировать класс.Большинство классов не нуждается в копировании и поэтому должны использовать *DISALLOW_COPY_AND_ASSIGN*.

#### Определение: 

Конструктор копирования используется при копировании одного объекта в новый объект (в особенности при передачи объектов по значению).

### Плюсы:

Конструкторы копирования позволяют легко копировать объекты. STL контейнеры требуют, чтобы все хранимые объекты могли быть скопированы и присвоены.

### Минусы:

Неявное копирование объектов в С++ является нескончаемым источником ошибок и проблем с производительностью.Оно также ухудшает читабельность, поскольку становится тяжело отслеживать какие объекты передаются по значению, а какие по ссылке, и следовательно затрудняя понимание того, были ли отражены изменения в объекте.

### Решение:

Большинству классов не требуется быть копируемыми и они не должны иметь конструктор копирования или оператор присвоения.К сожалению, если вы не определите их сами, компилятор создаст их за вас с публичным доступом.

Рассмотрите возможность создания объявлений пустышек конструкторов копирования и оператора присвоения в закрытой части класса, без кода.Объявляя эти функции закрытыми попытки их использования будут вызывать ошибку компиляции.Для удобства можно использовать макрос *DISALLOW_COPY_AND_ASSIGN*:

``` cpp
// Макрос для запрета конструктора копирования и оператора присвоения.
// Lолжно использоваться в закрытой части класса
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&);               \
  void operator=(const TypeName&)
```

Затем в классе Foo:

``` cpp
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&);               \
  void operator=(const TypeName&)

class Foo {
 public:
  Foo(int f);
  ~Foo();

 private:
  DISALLOW_COPY_AND_ASSIGN(Foo);
};
```

В почти всех случаях вашему классу следует использовать макрос *DISALLOW_COPY_AND_ASSIGN* так, как описано выше.Если ваш класс тот редкий случай, когда он должен быть копируемым, тогда задокументируйте причину этого в заголовочном файле класса и определите нужным образом конструктор копирования и оператор присваивания.Не забудьте проверить на самоприсвоение в *operator=*.

У вас может возникнуть желание сделать ваш класс копируемым для того, чтобы использовать его по значению в контейнерах STL.В большинстве подобных случаев следует сохранять в контейнере указатели на ваши объекты.Также вы возможно захотите использовать *std::tr1::shared_ptr*.

``` cpp
class Copyable {
 public:
  Copyable(const Copyable &) = default;
  Copyable &operator=(const Copyable &) = default;
  // Неявные операции перемещения подавляются объявлениями выше.
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly &&);
  MoveOnly &operator=(MoveOnly &&);

  // Операции копирования неявно удаляются, но вы можете изложить это явно,
  // если вы хотите:
  MoveOnly(const MoveOnly &) = delete;
  MoveOnly &operator=(const MoveOnly &) = delete;
};

class NotCopyableOrMovable {
 public:
  // Не копируемый или подвижный
  NotCopyableOrMovable(const NotCopyableOrMovable &) = delete;
  NotCopyableOrMovable &operator=(const NotCopyableOrMovable &) = delete;

  // Операции перемещения неявно отключены, но вы можете изложить это явно,
  // если вы хотите:
  NotCopyableOrMovable(NotCopyableOrMovable &&) = delete;
  NotCopyableOrMovable &operator=(NotCopyableOrMovable &&) = delete;
};
```

### Структуры или классы.

Используйте структуры только для пассивных объектов переносящих данные, все остальное является классом.

Ключевые слова *struct* и *class* ведут себя почти одинаково в 
С++.Мы добавляем наш собственный семантический смысл для каждого из этих ключевых слов с тем, чтобы вы использовали подходящее ключевое слово для определяемого типа данных.

Структуры следует использовать для пассивных объектов переносящих данные и возможно связанные с ними константы, но не несущие никакой функциональности кроме функций доступа к членам данных.Доступ к данным выполняется скорее по прямому доступу нежели чем через вызовы методов.Методам следует предоставлять не поведение, а только установку данных, например допустимы *конструктор, деструктор, Initialize(), Reset(), Validate()*.

Если требуется больше функциональности, тогда более уместно использовать класс.Если сомневаетесь, тогда создавайте класс.

Для единообразия с *STL* вы можете использовать структуры вместо класса для *функторов* и *traits*.

Обратите внимание, что поля в структурах и классах имеют различные правила имяобразования.

### Наследование

Композиция зачастую более уместна, чем наследование.При использовании наследования делайте его публичным.

#### Определение: 

Когда подкласс наследует от базового класса он включает определения всех данных и операций определенных в родительском классе.На практике наследование используется двумя основными способами в С++: 

  + наследование реализации, в которой производный класс наследует существующий код

  + интерфейсное наследование, в котором наследуются только имена методов.

#### Плюсы: 

Наследование реализации уменьшает размер программы посредством повторного использования кода базового класса в ходе специализации существующего типа.Поскольку наследование объявляется до компиляции, то вы и компилятор понимаете эту операцию и можете обнаружить ошибки программы до ее выполнения.Интерфейсное наследование может быть использовано для программного контроля определенного API неким классом.И в этом случае компилятор также может обнаружить ошибки, если класс не определяет необходимый метод API.

#### Минусы: 

При наследовании реализации, поскольку код наследуемого класса разнесен между классами родителя и наследника, может оказаться более сложным разобраться в логике программы.В наследнике невозможно переопределить не виртуальные функции и таким образом невозможно изменить реализацию.Базовый класс может также определить поля, что задает его физическую структуру.

#### Решение:

Любое наследование должно быть открытым.Если вы планируете использовать закрытое наследование, тогда лучше включите экземпляр базового класса в ваш класс вместо наследования.

Не злоупотребляйте наследованием реализации.Композиция зачастую более уместна.Постарайтесь использовать наследования только в случае отношения "является" между классами: *Bar* наследует от *Foo* только, если можно сказать, что *Bar* "является видом" *Foo*.

Объявляйте ваш деструктор виртуальным, если необходимо.Если ваш класс имеет виртуальные методы, тогда его деструктор также следует сделать виртуальным.

Делайте только те методы защищенными, которые должны быть доступны из производных классов.Обратите внимание, что элементы данных всегда должны быть закрытыми.

При переопределении наследуемой виртуальной функции всегда в явном виде объявляйте ее виртуальной.Причина - если модификатор *virtual* пропущен, тогда читающему ваш код придется проверять всех прародителей класса в поисках ответа на вопрос является эта функция виртуальной или нет.

### Множественное наследование.

Только в редких случаях множественное наследование на самом деле полезно.Мы позволяем множественное наследование в случае, если только один из базовых классов имеет реализацию, все остальные базовые классы должны быть чистыми интерфейсами помеченные суффиксом *Interface*.

#### Определение:

Множественное наследование позволяет наследнику иметь более одного родителя.Мы делаем различие между базовыми классами имеющими реализацию и чистыми интерфейсами.

#### Плюсы:

Множественное наследование позволяет вам повторно использовать еще больше кода, чем в единичном наследовании (*см.Наследование*).

### Минусы:

Только в очень редких случаях множественное наследование полезно.Когда кажется, что множественное наследование может являться решением, обычно вы можете найти другое, более ясное и чистое решение.

#### Решение: 

Множественное наследование разрешено только когда все родительские классы, за исключением возможно одного, являются чистыми интерфейсами.Для того, чтобы обеспечить то, что они останутся чистыми интерфейсами они должны завершаться суффиксом *Interface*.

#### Замечание: 

В Windows имеется исключение на это правило.

### Интерфейсы

Классы удовлетворяющие определенным условиям могут, хотя и не обязаны, завершаться суффиксом Interface.

#### Определение:

Класс является чистым интерфейсом если он удовлетворяет следующим требованиям:

  + Он имеет только публичные виртуальные (*"= 0"*) методы и статические методы (но см.ниже о деструкторе).

  + Он не имеет не статические члены данных.

  + Ему не нужно определять никакие конструкторы.Если есть конструктор, тогда он должен быть без аргументов и быть *protected*.

  + Если это подкласс, тогда он должен быть унаследован от классов удовлетворяющим этим условиям и помеченным суффиксом *Interface*.

Из-за чистых виртуальных функций невозможно создать экземпляр интерфейса.Для того, чтобы убедиться, что все реализации интерфейса могут быть корректно освобождены, они должны также объявить деструкторы виртуальными (являясь исключением первому правилу он не должен быть чисто виртуальным).
*См.Страуструп, The C++ Programming Language, 3-е издание, глава 12.4*.

#### Плюсы:

 Пометка класса суффиксом *Interface* дает другим знать, что запрещено добавлять методы с реализацией или нестатические члены данных.Это в особенности важно при множественном наследовании. Java программистам концепция интерфейса должна быть хорошо знакома.

#### Минусы:

 Суффикс Interface удлиняет имя класса, что может затруднить его чтение и понимание.К тому же, свойство интерфейса может быть рассмотрено как деталь реализации, которую не следует показывать клиентам.

#### Решение: 

Класс может заканчиваться словом *Interface* только, если он удовлетворяет всем вышеперечисленным условиям.Мы не требуем обратного, хотя, классы удовлетворяющие этим условиям не обязаны заканчиваться на *Interface*.

### Перегрузка операторов.

Не перегружайте операторы за исключением редких, специальных случаев.

#### Определение: 

Класс может определять операторы такие как + и / применяемые к классу как если бы он был встроенным типом.

#### Плюсы:

Позволяет писать код, который выглядит более интуитивно понятным, поскольку поведение класса похоже на поведение встроенных типов (таких как int).Перегруженные операторы - это просто более игривые названия для функций, названных менее ярко, таких как Equals() или Add().Для корректной работы некоторых шаблонных функций вам возможно понадобится определить операторы.

#### Минусы:

Хотя перегрузка операторов может сделать код более интуитивным, она несет и несколько недостатков:

  + Помогает обмануть нашу интуицию, заставляя думать, что дорогостоящая операция на самом деле не стоит много, как встроенные операции.

Гораздо сложнее найти места вызовов для перегруженных операторов.Заметно проще искать *Equals()*, чем соответсвующие вызовы *==*.

Некоторые операторы также работают с указателями, облегчая тем самым создание ошибок. `Foo + 4` может делать одно, а `&Foo + 4` может делать совершенно другое.Компилятор не будет жаловаться ни на одно из этих выражений, усложняя тем самым отладку.

Перегрузка также имеет неожиданные последствия.Например вы не можете предварительно объявлять классы которые переопределяют operator&.

#### Решение:

В общем случае не переопределяйте операторы.Оператор присвоения (*operator=*) в особенности вероломен и его следует избегать.Вы можете определить такие функции, как *Equals()* и *CopyFrom()* если они вам понадобятся.

Хотя, возможны случаи, когда вам нужно переопределить оператор для взаимодействия с шаблонами или "стандартными" С++ классами (такими как `operator<<(ostream&, const T&)` для записи логов).Эти случаи допустимы, если полностью обоснованы, но вы должны избегать этого по возможности.В особенности не переопределяйте *operator==* или *operator<* для того, чтобы ваш класс мог быть использован как ключ в контейнере STL.Вместо этого создавайте функторы равенства и сравнения при описании контейнера.

Некоторые алгоритмы STL требуют от вас перегрузки оператора ==, - в этих случаях вы можете делать это, при условии, что причина будет документирована.

*Смотри также Конструкторы Копирования и Перегрузка Функций.*

### Контроль доступа

Создавайте все члены данных закрытыми, предоставляя доступ к ним через функции чтения и записи по необходимости.Обычно переменная может называться *f00_* и функция чтения *foo()*.Вы может также создать функцию записи *set_foo()*.

Функции доступа обычно используют встроенное определение в заголовочном файле.

*Смотри также Наследование и Имена Функций.*

### Порядок описаний.

Используйте указанный порядок описаний внутри класса: *public:* перед *private:*, методы перед членами (переменными), и т.д.

Описание класса следует начинать с его *public:* части, затем следует его *protected:* часть и затем *private:* часть.Если какая-нибудь из этих частей пустая пропускайте ее.

Внутри каждой части объявления в общем случае следует делать в следующем порядке:

  + Typedef и Enum

  + Константы

  + Конструкторы

  + Деструкторы

  + Методы, включая статические методы

  + Члены данных, включая статические.

Вызов макроса *DISALLOW_COPY_AND_ASSIGN* следует размещать в конце private секции.Это должно завершать определение класса.Смотри Конструкторы Копирования.

Определения методов в соответсвующем .сс файле должны идти по возможности в таком же порядке, как они были декларированы.

## Функции

Не располагайте большие функции *inline* в определении класса.Обычно только простейшие или критичные по производительности, а также очень короткие, методы могут быть объявлены inline.
*Смотри подробнее в главе "Встроенные Функции".*

### Выходные параметры

Вывод функции C ++, естественно, обеспечивается через возвращаемое значение, а иногда и через выходные параметры.

Предпочитают использовать возвращаемые значения по сравнению с выходными параметрами: они улучшают читаемость и часто обеспечивают такую ​​же или лучшую производительность.Если используются только выходные параметры, они должны появляться после входных параметров.

Параметры либо вводятся в функцию, либо выводятся из функции, либо и то, и другое.Входные параметры обычно являются значениями или const ссылками, а выходные и входные / выходные параметры будут указателями на *non-const*.

### Пишите короткие функции.

Предпочитайте маленькие и специализированные функции.

Мы отдаем себе отчет, что длинные функции порой необходимы, поэтому не устанавливаем жесткого ограничения на их длину.Если функция превышает 40 строчек, тогда задумайтесь над тем может ли она быть разбита на несколько без вреда для структуры программы.

Даже если ваша длинная функция работает на данный момент безошибочно, через несколько месяцев кто-то может добавить новые функциональные возможности.В результате этого могут появиться трудно определимые ошибки.Создавая свои функции простыми и короткими вы облегчаете другим людям чтение и модификацию вашего кода.

Вы можете встретить длинные и сложные функции при чтении кода.Не бойтесь изменять существующий код: если работать с подобной функцией сложно, ошибки отлаживать тяжело, или вы хотите использовать его часть в нескольких других местах, постарайтесь разбить функцию на более маленькие и управляемые куски.

### Умные указатели.

Если вам на самом деле нужна семантика указателя, тогда подойдет *scoped_ptr*.Следует использовать *std::tr1::shared_ptr* только в очень определенных условиях, например при хранении объекта в STL контейнере.Никогда не стоит использовать *auto_ptr*.

"Умные" указатели являются объектами, которые ведут себя как указатели, но имеют добавленную семантику.Например, когда уничтожается *scoped_ptr*, то удаляется также объект, на который он указывает.*shared_ptr* ведет себя подобным образом, но использует счетчик ссылок таким образом, что только последний уничтожаемый указатель на объект удалит его.

Вообще говоря, мы предпочитаем проектировать код так, чтобы было понятно кто владеет объектом.Наиболее просто это достигается при использовании объекта напрямую в качестве поля или локальной переменной, без применения указателей вообще.На другой стороне спектра находятся указатели считающие ссылки, поскольку по определению не имеют владельца.Проблема этой схемы в том, что при этом очень легко создать круговые ссылки или другие странные условия, при которых объект никогда не будет удален.Также замедляются атомарные операции, когда значение копируется или присваивается.

Хотя они и не рекомендуются, указатели считающие ссылки иногда являются простейшим и наиболее элегантным решением проблемы.

### Ссылочные аргументы.

Все параметры передаваемые по ссылке должны быть помечены *const*.

#### Определение:

В С, если функции требуется изменить переменную, тогда параметр должен использовать указатель.Например, `int foo(int *pval)` .В С++ функция альтернативно может может декларировать ссылочный параметр: `int foo(int &val)` .

#### Плюсы:

Передавая параметр по ссылке исключается безобразный код вроде `(*pval)++` .Это также необходимо в некоторых приложения, как например конструкторах копирования.Делает очевидным, в отличие от указателей, что NULL не является возможным значением.

#### Минусы:

Cсылки могут вносить путаницу, поскольку имеют синтаксис параметра по значению, но семантику указателей.

#### Решение:

Все ссылочные параметры функции должны быть const:

``` cpp
void Foo(const string &in, string *out); 
```

На самом деле это очень серьезное соглашение, что в коде Google входные аргументы являются либо значениями, либо неизменными ссылками, в то время как исходящие аргументы являются указателями.Входящие аргументы могут быть неизменными указателями, но мы никогда не позволяем неконстантные ссылки в качестве параметров.

Примером того, когда вы возможно захотите использовать неизменный указатель для входящего параметра является случай, когда вы хотите подчеркнуть, что аргумент не копируется и значит должен существовать в течении всего времени существования этого объекта; лучше всего, если это также будет отражено в документации.Вам также придется использовать указатели в параметрах функций при использовании таких STL адаптеров, как `bind2nd` и `mem_fun` , поскольку они не позволяют ссылочные параметры.

### Перегрузка функций

Используйте перегрузку функций (включая конструкторы) только в случаях, когда входные данные могут быть указаны различными типами данных, но содержащих одну и ту же информацию.Не используйте перегрузку функций для симуляции параметров по умолчанию.

#### Определение:

Ты можешь написать функцию которая принимает константу string и перегружает ее другой константой char*.

``` cpp
class MyClass {
 public:
  void Analyze(const string &text);
  void Analyze(const char *text, size_t textlen);
};
```

#### Плюсы: 

Перегрузка может сделать код более интуитивным, позволяя одноименным функциям принимать различные аргументы.Это может быть необходимым для кода шаблонов, и может быть удобным для посетителей.

#### Минусы:

Одной из причин минимизации перегрузки функций является то, что из-за нее сложно сказать какая функция вызывается в месте вызова.Другая причина заключается в том, что многие люди путаются в семантике наследования в том случае, когда наследуемый класс замещает только часть из доступных вариантов функций.Более того, чтение клиентского кода библиотеки может стать неоправданно сложным из-за всех причин против использования параметров по умолчанию функции.

#### Решение:

Если вы хотите перегрузить функцию, предпочтите изменить имя подходящим образом, включив в него информацию об аргументах.Например, `AppendString()` , `AppendInt()` лучше чем просто `Append()` .

### Аргументы по умолчанию

Аргументы по умолчанию разрешены для не виртуальных функций, если гарантируется, что значение по умолчанию всегда будет иметь одинаковое значение.

#### Плюсы: 

Зачастую у вашей функции есть много значений по умолчанию, но иногда вы хотите изменить их.Параметры по умолчанию предоставляют легкий способ сделать это без определения множества функций для этих редких исключений.

#### Минусы:

Люди часто изучают API по примерам его использования в существующем коде.Параметры по умолчанию более тяжело сопровождать поскольку простое копирование из предыдущего кода не обязательно содержит всех параметров.Перенос сегментов кода может вызвать большие проблемы в случае, если аргументы по умолчанию не подходят для нового кода.

#### Решение: 

Мы требуем, чтобы все аргументы были заданы в явном виде.Это заставляет программистов задумываться над API и значениями передаваемыми в каждый параметр, вместо молчаливого принятия значений по умолчанию, о которых они могут и не подозревать.

## Другие особенности C ++

### Массивы переменной длины и alloca()

Мы не разрешаем массивы переменной длины и `alloca()` .

#### Плюсы:

Массивы переменной длины имеют естественно выглядящий синтаксис.И массивы переменной длины и `alloca()` весьма эффективны.

#### Минусы:

Ммассивы переменной длины и `alloca()` не являются частью стандартного С++.Что более важно, они размещают зависимое от данных количество памяти в стеке, что может вызвать трудно определимые ошибки перезаписи памяти: "Все работало отлично на моей машине, но умерло загадочным образом в производстве".

#### Решение:

Используйте безопасное размещение памяти, такое как `scoped_ptr/scoped_array` .

### Друзья

Мы позволяем использование дружественных классов и функций в разумных пределах.

Друзья обычно должны быть определены в одном файле, так что читатель не должен заглядывать в другой файл для того, чтобы найти его частные методы.Частым использованием дружественности класса является создание класса `FooBuilder` дружественным классу `Foo` с тем, чтобы он мог корректно создать внутреннее состояние `Foo` , без открытия его внутреннего устройства внешнему миру.В некоторых случаях может оказаться полезным сделать класс *unit теста* дружественным тестируемому классу.

Друзья расширяют, но не разрушают границы изоляции класса.В некоторых случаях, когда все что вам нужно - это дать доступ одному классу к члену другого класса, лучше объявить другом, чем дать открытый доступ к этому члену.

### Исключения

Мы не используем С++ исключения.

#### Плюсы:

Исключения позволяют более высоким уровням приложения решать как обрабатывать "невозможные" ошибки в глубоко вложенных функциях, без запутывающего и склонного к ошибкам учета кодов ошибок.

Исключения используются большинством современных языков.Использование их в С++ могло бы сделать его более согласованным с Python, Java, and the C++ используемого другими.

Некоторые сторонние С++ библиотеки используют исключения и их отключение делает интеграцию с ними затруднительной.

Исключения являются единственным способом потерпеть неудачу в конструкторе.Мы может симулировать это *factory функцией* или методом `Init()` , но с ними потребуется размещение в динамической памяти, либо новое "некорректное" состояние соотвественно.

Исключения очень полезны при тестировании фреймворков.

#### Минусы: 

Когда вы добавляете исключение в существующей функции вы должны проверить все ее промежуточные вызовы.Либо они должны обеспечить как минимум базовую безопасность исключений, либо они не должные обрабатывать исключений и не беспокоиться о том, что программа может быть прекращена в результате этого.Например, если `f()` вызывает `g()` , которая вызывает `h()` , и `h` вызывает исключение обрабатываемое в `f` , `g` должна быть внимательной, в противном случае она может не вернуть ресурсы системе должным образом.

Говоря в целом, исключения затрудняют оценку управляющей логики программы при просмотре кода, поскольку возврат из функции может происходить в неожиданных местах.Это приводит к сложностям сопровождения и отладки.Вы можете минимизировать этот эффект введя некие ограничения на то, как и когда исключения могут быть использованы, но ценою того, что разработчику нужно будет знать и понимать больше, чем необходимо.

Безопасность исключений требует использования как RAII, так и различных правил кодирования.Написание корректного безопасного кода с исключениями требует множество поддерживающих технологий.Более того, для того, чтобы не заставлять читателя понимать всю схему вызовов, безопасный код с исключениями должен изолировать логику записи постоянного состояния в "фиксирующую" фазу транзакции.Использование исключений заставило бы нас всегда платить эту цену, даже тогда, когда оно того не стоит.

Включение исключений увеличивает размер программы, время компиляции (возможно незначительно) и с вероятностью увеличивает нагрузку на адресное пространство.

Доступность исключений может вдохновить разработчика на то, чтобы вызывать их, когда это не уместно, или восстанавливаться от них, когда это делать небезопасно.Например, неверный ввод пользователя не должен вызывать исключения.Мы должны были бы написать еще более длинное руководство по стилю для документации всех этих ограничений!

#### Решение:

На первый взгляд выгода от использования исключений перевешивает расходы, особенно в новых проектах.Хотя для существующего кода ввод исключений имеет осложнения для всего зависимого кода.Если исключения могут распространяться за пределы нового проекта, то интеграция существующего кода без исключений с подобным проектом становиться проблематичной.Поскольку большинство существующего С++ кода в Google не готово работать с исключениями, то адаптация нового кода с исключениями становится относительно сложна.

С учетом того, что существующий код Google-а не допускает исключений, то цена их использования выше, чем в новых проектах.Процесс модернизации был бы медленным и склонным к ошибкам.Мы не верим, что существующие альтернативы исключениям - коды ошибок и их проверка - привносят значительные накладные расходы.

Наш совет против использования исключений не происходит из философских или моральных мотивов, но из практических соображений.Поскольку мы в Google хотели бы использовать проекты с открытым кодом и это тяжело делать при использовании исключений мы вынуждены также отсоветовать их использование в Google проектах с открытым кодом.Все могло бы быть иначе начни мы все снова с нуля.

Имеется только одно исключение к этому правилу (не сочтите за каламбур) для Windows кода.

### Информация о типе этапа выполнения (RTTI - Run-Time Type Information)

Мы не используем информацию о типе этапа выполнения (RTTI)

#### Определение: 

RTTI позволяет программисту запрашивать С++ класс информацию об объекте на этапе выполнения.

#### Плюсы:

Это бывает полезным в некоторых юнит тестах.Например, это полезно при тестировании фабричных классов, когда тест должен убедиться, что созданный объект имеет ожидаемый динамический тип.

В некоторых случает это бывает полезным даже вне тестов.

``` cpp
bool Base :: Equal (Base * other) = 0; 
bool Derived :: Equal (Base * other) { 
  Derived * that = dynamic_cast <Derived *> (other); 
  if (that == nullptr) 
    return false; 
  ... 
}
```

#### Минусы: 

Запрос о типе на этапе выполнения обычно означает проблему в проектировании.Если вам необходимо узнать тип объекта во время выполнения, то зачастую это является признаком того, что вам следует пересмотреть проект вашего класса.

#### Решение:

Не используйте RTTI кроме как в юнит тестах.Если вы обнаруживаете себя в ситуации, когда вы пишете код, ведущий себя различно в зависимости от класса объекта, задумайтесь об альтернативах использования типа.

Виртуальные методы являются предпочтительным способом выполнения различных ветвей кода в зависимости от специфичности типа класса.В этом случае вся работа возлагается на сам объект.

Если эта работа должна быть выполнена снаружи объекта в неком обрабатывающем коде, тогда рассмотрите вариант использования решение двойного распределения, как в шаблоне проектирования "Посетитель" (*Vistior*).Это позволит программе снаружи самого объекта определить тип и класс используя встроенную систему типов.

Если вы думаете, что и в самом деле не сможете воспользоваться этими идеями, тогда вы можете использовать RTTI.Но подумайте об этом дважды.:-) И затем еще два раза.Не надо разрабатывать заплатки по типу RTTI.Аргументы против RTTI в той же мере применимы и костылям вроде иерархии классов с тегами типов.

### Приведение типов.

Используйте такие приведения типов C++, как `static_cast<>()` .Не используйте другие форматы приведения типов таких, как `int y = (int)x;` или `int y = int(x);` .

#### Определение: 

С++ представил отличную от С систему приведения типов, которая различает типы приведений.

#### Плюсы: 

Проблема с приведением типов в С заключается в двусмысленности этой операции: иногда вы выполняете конвертирацию (например `(int)3.5` ), а иногда вы выполняете приведение типа (например, `(int)"hello"` ).Приведение типов в С++ избегает этого.К тому же приведение типов в С++ более заметны и легче находятся.

#### Минусы: 

Неприятный синтаксис.

#### Решение:

Не используйте приведение типа в стиле С.Используйте С++ приведения вместо этого.

Используйте `static_cast` вместо приведения типов в стиле С, которое выполняет преобразование значений, или когда необходимо в явном виде привести тип базового класса к его потомку.

Используйте `const_cast` для удаления спецификатора const (см.*const*).

Используйте `reinterpret_cast` для небезопасного преобразования указателей в и из целого и других указательных типов.Используйте это только, если вы знаете что делаете и понимаете проблемы с использованием псевдонимов.

Не используйте `dynamic_cast` , за исключением тестирующего кода.Если вам нужна информация о типе на этапе исполнения вне юнит теста, то вероятно имеется недостаток в проектировании.

### Потоки <<

Используйте потоки только для ведения логов.

### Определение: 

Потоки являются заменой для `printf()` и `scanf()` .

#### Плюсы: 

C потоками вам не нужно знать тип печатаемого объекта.У вас нет проблем с форматирующими строками не соответствующими списку аргументов.(Впрочем с gcc у вас также нет этой проблемы с `printf` ).Потоки имеют автоматические конструкторы и деструкторы открывающие и закрывающие соответсвующие файлы.

#### Минусы:

Потоки затрудняют использовать такие функции как `pread()` .При использовании потоков некоторое форматирование (в особенности стандартная строковая идиома `%.*s` ) затруднено, если не невозможно без применения сходных `printf` ухищрений.Потоки не поддерживают перестановку операторов ( `%1s` директива), которая весьма полезна при интернационализации.

#### Решение:

Не используйте потоки, за исключением когда это требуется интерфейсом ведения протокола.Используйте `printf` и прочие сходные с ним функции.

Имеются различные плюсы и минусы использования потоков, но в этом случае, как и во многих других, единообразие перевешивает чашу весов.Не используйте потоки в вашем коде.

### Расширенное Обсуждение

Поскольку этот вопрос горячо обсуждался здесь мы объясним причины более подробно.Припомните руководствующий принцип "Только Единственным Способом": мы хотим убедиться, что когда бы мы не выполняли определенный тип I/O, код будет выглядеть одинаково везде.По этой причине мы не хотим позволять пользователям решать между потоками или использованием `printf` вместе с *Read/Write/* и т.д.Вместо этого мы должны выбрать одно или другое.Мы сделали исключение для протоколирования, поскольку это довольно специализированное приложение, а также по историческим причинам.

Защитники потоков спорили, что потоки являются более очевидным выбором из двух, но ответ в действительности не так прост .Для каждого указанного ими преимущества потоков имеется эквивалентный недостаток.Наибольшее преимущество заключается в том, что вам не нужно знать тип печатаемого объекта.Это справедливый довод.Но он имеет и обратную сторону: вы может легко использовать не тот тип и компилятор вас не предупредит.Этот тип ошибок очень легко допустим при использовании потоков:

``` cpp
cout << this; // печатает адрес
cout << *this; // печатает содержимое
```

Компилятор не сгенерирует ошибки, поскольку << был перегружен.Мы не советуем использовать перегрузку именно по этой причине.

Кто-то скажет форматирование в `printf` безобразно и трудночитаемо, но потоки зачастую не лучше.Рассмотрите следующие два фрагмента, оба с одной и той же опечаткой.В какой из них ее легче обнаружить?

``` cpp
cerr << "Error connecting to '" << foo->bar()->hostname.first
<< ":" << foo->bar()->hostname.second << ": " << strerror(errno); 
fprintf(stderr, "Error connecting to '%s:%u: %s", 
foo->bar()->hostname.first, foo->bar()->hostname.second, 
strerror(errno)); 
```

И так по любому возникающему в этой связи вопросы.Вы можете сказать, что "использование оберток могло бы улучшить ситуацию", но если это так в одном случае, это не обязательно.Также, не забываем, что задача - сделать язык меньше, а не добавить еще один механизм, который кому-то придется изучать.

Любой из этих путей имеет различные преимущества и недостатки без явного преимущества одного на другим.Однако доктрина простоты требует выбора одного из них, и большинство решений было в пользу *printf + read/write*.

### Прединкремент и постинкремент

Используйте префиксную форму (++i) операторов инкремента и декремента с итераторами и прочими шаблонными объектами.

#### Определение:

Когда переменная увеличивается (++i или i++) или уменьшается (--i или i--) и при этом значение выражения не используется, нужно решить использовать ли прединкремент\декремент или постинкремент\декремент.

#### Плюсы: 

Когда возвращаемое значение игнорируется "пре" форма (++i) никогда не бывает менее эффективной, чем "пост" форма (i++), а зачастую является более эффективной.Это так потому, что постинкремент (или декремент) требует создания копии i (значения выражения).Если i является итератором или любым другим не скалярным типом, копирование i может быть дорогостоеящей операцией.Поскольку оба варианта равнозначны, когда значение игнорируется, то почему бы не использовать всегда прединкремент?

#### Минусы:

По традиции, когда значение выражения не учитывалось, в С использовался постинкремент, особенно в циклах `for` .Кому то постинкремент кажется более простым для чтения, поскольку "объект" (i) предшествует "глаголу" (++), как это принято в английском языке.

#### Решение: 

Для простых скалярных (не объектных) значений не имеет значения какую из форму предпочесть и мы допускаем любую.Для итераторов и других шаблонных типов всегда используйте прединкремент.

### Использование const

Мы настойчиво рекомендуем использовать const везде, где это имеет смысл.

#### Определение: 

Объявление переменных или параметров может быть предварено ключевым словом `const` для обозначения того, что эти переменные неизменны (например, `const int foo` ).Функции классов могут иметь квалификатор `const` для обозначения того, что они не могут изменить состояния переменных класса (например, `class Foo { int Bar(char c) const; };` ).

#### Плюсы:

Людям проще понимать, как используются переменные.Позволяет компилятору выполнять лучше проверку типов, и, возможно, генерировать более надежный код.Позволяет людям иметь уверенность в правильности программы, поскольку они знают, что вызываемые функции ограничены в том, как они могут модифицировать свои переменные.Помогает распознавать функции безопасные для использования в много-поточных программах без блокировок.

#### Минусы:

`const` заразен: если вы передаете `const` переменную в функцию, тогда эта функция должна иметь `const` в своем прототипе (в противном случае переменной потребуется `const_cast` ).В особенности это может оказаться проблемой при вызове библиотечных функций.

#### Решение:

Константые переменные, члены данных, методы и аргументы добавляют уровень проверки типов на этапе компиляции; лучше определять ошибки как можно раньше.По этой причине мы настойчиво рекомендуем использовать const везде, где это имеет смысл.

Если функция не изменяет аргумента передаваемого по ссылке или указателю, тогда этот аргумент должны быть const.

Объявляйте методы const всегда, когда возможно.Методы чтения почти всегда должны быть const.Прочие методы должны быть const, если они не изменяют членов данных, не вызывают не const методы и не возвращают не const указатели на члены данных.

Рассмотрите возможность объявления членов данных const в тех ситуациях, когда они не должны изменяться после создания.

Хотя не переусердствуйте с const.Например " `const int * const * const x` " вероятно перегиб, несмотря на то, что аккуратно описывает насколько неизменно x.Фокусируйте на том, что действительно полезно знать: например в данном случае вероятно достаточным будет " `const int** x` ".

Ключевое слово `mutable` допускается, но небезопасно при использовании с потоками, так что безопасность потоков должна рассматриваться в первую очередь.

#### Где размещать const

Некоторые люди предпочитают форму `int const *foo` форме `const int* foo` .Они утверждают, что это более читабельно, поскольку более последовательно, так как следует правилу размещать const всегда после описываемого объекта.Однако этот аргумент не применим в данном случае, поскольку диктум "не переусердствуйте" уничтожает большинство случаев с которыми вам нужно было бы быть последовательным.Размещение `const` вначале вероятно более читабельно, поскольку следует английскому в правиле размещения прилагательного ( `const` ) перед существительным ( `int` ).

С другой стороны, хотя мы и поддерживаем размещение const вначале, мы не настаиваем на этом.Просто будьте последовательны с кодом вокруг вас!

### Использование constexpr

Используется `constexpr` для определения истинных констант или для обеспечения постоянной инициализации.

#### Определение: 

Некоторые переменные могут быть объявлены, `constexpr` чтобы указать, что переменные являются истинными константами, т.е.зафиксированы во время компиляции / соединения.Некоторые функции и конструкторы могут быть объявлены, `constexpr` что позволяет использовать их при определении `constexpr` переменной.

#### Плюсы:

Использование `constexpr` позволяет определять константы с помощью выражений с плавающей точкой, а не просто литералов; определение констант пользовательских типов; и определение констант с вызовами функций.

#### Минусы:

Преждевременная маркировка чего-либо как `constexpr` может вызвать проблемы с миграцией, если в дальнейшем это придется понизить.Существующие ограничения на то, что разрешено в функциях и конструкторах constexpr, могут привести к неясным обходным путям в этих определениях.

#### Решение:

`constexpr` определения позволяют более надежную спецификацию константных частей интерфейса.Используется `constexpr` для указания истинных констант и функций, которые поддерживают их определения.Избегайте сложных определений функций, чтобы разрешить их использование с `constexpr` .Не используйте `constexpr` для принудительного встраивания.

### Целые типы

Из всех встроенных в С++ целых типов используйте только один `int` .Если программе необходима переменная другого размера, тогда используйте целые заданного размера из `<stdint.h>` , например `int16_t` .

#### Определение:

С++ не определяет размеры целых типов.Обычно подразумевают, что `short` занимает 16 бит, `int` - 32 бита, `long` - 32 бита, и `long long` - 64 бита.

#### Плюсы:

Единообразие объявлений.

#### Минусы:

Размеры целых типов в С++ могут различаться в зависимости от компилятора и архитектуры (процессора).

#### Решение:

Файл `<stdint.h>` определяет такие типы, как `int16_t` , `uint32_t` , `int64_t` и т.д.Вы всегда должны использовать их предпочтельно перед типами `short` , `unsigned long` , `long` и т.п., когда вам необходимо гарантировать размер типа `integer` .Из целочисленных типов языка С должен быть использован только тип `INT` .При необходимости, вы можете использовать такие стандартные типы, как `size_t` и `ptrdiff_t` .

Мы используем `INT` очень часто, для чисел мы знаем, не будет слишком большим, например счетчики циклов.Используйте простой старый `INT` для таких целей.Вы должны предположить, что размер `INT` составляет не менее 32 бит, но не предполагаете, что она имеет более чем 32 бит.Если вам нужен 64-битный целочисленный тип, используйте `int64_t` или `uint64_t` .

Для чисел, которые могут быть "большими", используйте `int64_t` .

Вы не должны использовать беззнаковые типы данных, такие как `uint32_t` , за исключением случаев если вы используете переменную в качестве маски, а не численного значения, или вам надо определить переполнение в двоичном дополнительном коде.В частности, не используйте беззнаковые типы чтобы показать что значение переменной не может быть отрицательным.Для этого используйте *assert-макросы*.

### О беззнаковых числах

Некоторые люди, включая авторов этой книги, рекомендуют использовать беззнаковые типы для представления чисел, которые никогда не должны быть отрицательными.Это также одна из форм само-документирования.Тем не менее, в C, преимущества такой документации омрачаются реальными ошибками.Рассмотрим:

``` cpp
for (unsigned int i = foo. Length()-1; i >= 0; --i) ... 
```

Этот код никогда не завершится! Иной раз gcc предупредит вас об этом баге, но этого может и не произойти.Такой же баг может проявиться когда вы будете сравнивать знаковые и беззнаковые переменные.По сути, схема представления типов в языке C является причиной, почему беззнаковые типы ведут себя по-другому.

Таким образом, документ о том, что если ваша переменная должна быть неотрицательной, используйте assert-макросы для проверки.

Не используйте беззнаковые типы.

#### 64-х битная совместимость

Код должен одинаково хорошо работать как на 64-х битных, так и на 32-х битных системах.Всегда помните о проблемах печати, сравнения и выравнивания структур.

Помните, что `sizeof(void *) != sizeof(int)` .Используйте `intptr_t` , если вам нужен целочисленный указатель.

Вы должны быть осторожны с выравниванием структур (если Вы не поняли о чем тут идет речь: http://en.wikipedia.org/wiki/Data_structure_alignment, прим.переводчика), в особенности для структур, находящихся на диске.Класс/структура, содержащие переменные типа `int64_t/uint64_t` будут, по умолчанию, дополнены до 8-байт на 64-битных системах.Если у вас есть структуры, которые должны совместно использоваться в 32 и 64-битном коде, вам необходимо убедиться, что они одинаково упакованы на обоих архитектурах.Большинство компиляторов предоставляют возможность изменить выравнивание структуры.В gcc: `__attribute__((packed))` , в MSVC: `#pragma pack()` и `__declspec(align())` .

Используйте LL или ULL суффиксы если необходимо создать 64-битовые константы.Например:

``` cpp
int64_t my_value = 0x123456789LL; 
uint64_t my_mask = 3ULL << 48; 
```

Если вы действительно нуждаетесь в различном коде на 32-битовых и 64-битовых системах, используйте `#ifdef _LP64` , чтобы выбрать между вариантами кода.(Но пожалуйста избегайте этого если возможный, и сохраните любые такие изменения ограниченными.)

### Макросы предпроцессора

Будьте очень внимательны с макросами.Отдавайте предпочтение встроенным функциям и константам.

Наличие макроса означает, что код, который вы видите не является кодом, который видит компилятор.Это может внести непредвиденное поведение, тем более, что макросы обладают глобальной областью видимости.

К счастью, необходимость макросов в С++ значительно ниже, чем в С.Вместо использования макроса для вставки критичного для выполнения кода используйте `inline` функции.Вместо использования макроса для хранения константы, используйте `const` переменную.Вместо использования макроса для "сокращения" длинного имени переменной используйте ссылку.Вместо использования макроса для условной компиляции... лучше не делайте этого вовсе (за исключением, конечно, защитных инструкций `#define` для предотвращения двойного включения заголовочных файлов).Использование макросов в этих целях значительно затрудняет тестирование.

Макросы могут делать вещи, которые перечисленными техниками не добиться, и вы можете увидеть их в исходниках, в особенности в низкоуровневых библиотеках.Некоторые свойства макросов (как например перевод в строку, конкатенация и т.д.) не доступны через средства языка непосредственно.Но перед использованием макроса, внимательно задумайтесь имеется ли не макросовый способ достижения тоже самого результата.

Следующие шаблоны использования помогут избежать множества проблем с макросами.Если вы используете макросы используйте их при всякой возможности:

  + Не определяйте макросы в .h файле.

  + `#define` макросы непосредственно перед использованием и сразу после этого `#undef` их.

  + Никогда не `#undef` существующий макрос с тем, чтобы заменить его своим собственным, вместо этого выберите имя, которое скорее всего будет уникальным.

  + Старайтесь не использовать макросы разворачивающиеся в несбалансированные конструкты С++, или, по крайней мере, тщательно это документируйте.

### 0 и nullptr / NULL

Используйте 0 для целых, 0.0 для действительных, `nullptr / NULL` для указателей и `'\0'` для символьных переменных.

Используйте 0 для целых и 0.0 для действительных чисел.Это не спорный вопрос.

Для указателей (адресных значений) есть выбор между 0 и `nullptr / NULL` .Бъерн Страуструп предпочитает бесхитростный 0.Мы предпочитаем `nullptr` потому что это выглядит как указатель.На самом деле некоторые компиляторы С++, предоставляют специальное определение `nullptr` , позволяющее им выдавать полезные предупреждения, в особенности в ситуациях когда `sizeof(nullptr)` , не равно `sizeof(0)` .

Используйте `'\0'` для символьных переменных.Это корректный тип и к тому же улучшает читабельность кода.

### sizeof

Используйте `sizeof(varname)` вместо `sizeof(type)` , где возможно.

Используйте `sizeof(varname)` поскольку это будет работать в случае, если тип переменной измениться. `sizeof(type)` может быть использовано в некоторых случаях, но в целом должно избегаться, поскольку этот вариант выпадает из контекста при изменении типа переменной.

``` cpp
Struct data; 
memset(&data, 0, sizeof(data)); // OK
memset(&data, 0, sizeof(Struct)); // Bad
``` 

### Лямбда-выражения

При необходимости используйте лямбда-выражения. Предпочитаю явные захваты, когда лямбда выйдет из текущей области видимости.

### Определение

Лямбда-выражения - это краткий способ создания объектов анонимных функций. Они часто полезны при передаче функций в качестве аргументов. Например:

``` cpp
std::sort(v.begin (), v.end (), [] (int x, int y) { 
  return Weight(x) <Weight(y); 
});
```

Кроме того, они позволяют захватывать переменные из охватывающей области либо явно по имени, либо неявно, используя захват по умолчанию.Для явного захвата требуется, чтобы каждая переменная была указана в виде значения или ссылки:

``` cpp
int weight = 3; 
int sum = 0; 
// Захватывает `weight` по значению и ` sum` по ссылке. 
std::for_each(v.begin(), v.end(), [weight & sum](int x) { 
  sum + = weight * x; 
});
```

Захваты по умолчанию неявно захватывают любую переменную, на которую ссылается лямбда-тело, в том числе `this` если используются какие-либо члены

``` cpp
const std::vector<int> lookup_table = ...; 
std::vector<int> indices = ...; 
// Захватывает `lookup_table` по ссылке, сортирует ` индексы` по значению 
// соответствующего элемента в `lookup_table` . 
std::sort(indices.begin(), indices.end(), [&](int a, int b) { 
  return lookup_table [a] <lookup_table [b]; 
});
```

Перехват переменных также может иметь явный инициализатор, который можно использовать для захвата переменных, перемещаемых только по значению, или для других ситуаций, не обрабатываемых обычной ссылкой или захватом значений:

``` cpp
std::unique_ptr<Foo> foo = ...; 
[foo = std::move(foo)]() { 
  ... 
}
```

Такие захваты (часто называемые «захватом инициализации» или «обобщенными лямбда-захватами») на самом деле не должны «захватывать» что-либо из внешней области видимости или даже иметь имя из внешней области видимости; этот синтаксис является полностью общим способом определения членов лямбда-объекта:

``` cpp
[foo = std :: vector <int> ({1, 2, 3})] () { 
  ... 
}
```

Тип захвата с инициализатором выводится с использованием тех же правил, что и `auto` .

#### Плюсы:

Лямбды являются гораздо более краткими, чем другие способы определения функциональных объектов для передачи в алгоритмы STL, что может улучшить читаемость.

Надлежащее использование захватов по умолчанию может удалить избыточность и выделить важные исключения из значений по умолчанию.

Лямбды, `std::function` и `std::bind` могут использоваться в комбинации как механизм обратного вызова общего назначения, они облегчают написание функций, которые принимают связанные функции в качестве аргументов.

#### Минусы:

Перехват переменных в лямбдах может быть источником ошибок висячих указателей, особенно если лямбда выходит за пределы текущей области видимости.

Захваты по умолчанию по значению могут вводить в заблуждение, поскольку они не предотвращают ошибки висячих указателей.Захват указателя по значению не вызывает глубокого копирования, поэтому он часто имеет те же проблемы времени жизни, что и захват по ссылке.Это особенно сбивает с толку при захвате «this» по значению, поскольку использование «this» часто подразумевается.

Захваты фактически объявляют новые переменные (независимо от того, есть ли у них инициализаторы), но они не похожи ни на какой другой синтаксис объявления переменных в C ++.В частности, нет места для типа переменной или даже `auto` заполнителя (хотя перехваты `init` могут указывать на это косвенно, например, с помощью приведения).Это может затруднить даже признание их как декларации.

Захваты Init по своей сути полагаются на дедукцию типов и страдают от многих из тех же недостатков `auto` , что и дополнительная проблема, заключающаяся в том, что синтаксис даже не подсказывает читателю, что дедукция происходит.

Можно использовать лямбды, чтобы выйти из-под контроля; очень длинные вложенные анонимные функции могут усложнить понимание кода.

#### Решение

При необходимости используйте лямбда-выражения с форматированием, как описано ниже .

Предпочитайте явные перехваты, если лямбда может выйти за пределы текущей области Например, вместо:

``` cpp
{ 
  Foo foo; 
  ... 
  executor-> Schedule ([&] {Frobnicate (foo);}) 
  ... 
} 
// ПЛОХО! Тот факт, что лямбда использует ссылку на `foo` и 
// возможно ` this` (если `Frobnicate` является функцией-членом) не может быть 
// очевиден при беглом осмотре. Если лямбда вызывается после 
// возврата функции, это было бы плохо, потому что и `foo` 
// и окружающий объект могли быть уничтожены.
```

предпочитаю писать:

``` cpp
{ 
  Foo foo; 
  ... 
  executor-> Schedule ([& foo] {Frobnicate (foo);}) 
  ... 
} 
// ЛУЧШЕ - Компиляция завершится неудачно, если `Frobnicate` является членом 
// функции, и станет понятнее, что ` foo` опасно захвачен 
// ссылкой.
```

Используйте захват по умолчанию по ссылке ([&]) только тогда, когда время жизни лямбда явно короче, чем любые потенциальные захваты.

Используйте захват по умолчанию по значению ([=]) только как средство привязки нескольких переменных для короткой лямбды, где набор захваченных переменных очевиден с первого взгляда.Не пишите длинные или сложные лямбды с захватом по умолчанию по значению.

Используйте захваты только для фактического захвата переменных из окружающей области.Не используйте захваты с инициализаторами для введения новых имен или для существенного изменения значения существующего имени.Вместо этого объявите новую переменную обычным способом и затем перехватите ее, или избегайте лямбда-сокращения и явно определяйте объект функции.

## Наименования

К наиболее важным правилам единообразия относятся те, которые управляют присваиванием имен.Стиль имени немедленно информирует нас о том с какого рода именованной сущностью мы имеем дело (тип, переменная, функция, константа, макрос и т.д.) без необходимости поиска объявления этой сущности.Шаблонно-поисковая машина в нашем мозге в большой степени зависит от этих правил именования.

Правила именования вполне произвольны, но мы полагаем, что согласованность тут важней персональных предпочтений, так что в независимости от того, найдете ли вы разумными или нет - эти правила остаются правилами.

### Общие правила имяобразования

Имена функций, переменных и файлов должны быть описательными, воздерживайтесь от аббревиатур.Типы и переменные должны быть именами существительными, в то время как функции должны быть "командными" глаголами.

Как именовать.

Задавайте описательное имя по возможности, в разумных пределах.Не беспокойтесь об экономии горизонтального пространства - гораздо важнее сделать ваш код моментально понятным постороннему читателю.Примеры хорошо выбранных имен:

``` cpp
int num_errors; // Хорошо.
int num_completed_connections; // Хорошо.
```

Плохо выбранные имена используют неясные сокращения или произвольные символы не передающие смысла:

``` cpp
int n; // Плохо - бессмысленное имя.
int nerr; // Плохо - не очевидное сокращение.
int n_comp_conns; // Плохо - не очевидное сокращение.
```

Имена для типов и переменных обычно должны быть существительными, например: FileOpener, num_errors.

Имена функций обычно должны быть императивными (т.е.они должны быть коммандами), например: OpenFile(), set_num_errors().Исключением являются функции доступа, которые, как более подробно будет описано в "Имена Функций", следует называть так же, как и переменную к которой они открывают доступ.

### Сокращения.

Не используйте сокращения, за исключением случаев, когда они отлично известны за рамками вашего проекта.Например:

``` cpp
// Примеры хороших имен.
// Здесь продемонстрированы правильные имена без сокращений.
int num_dns_connections; // Большинство людей знают что означает "DNS".
int price_count_reader; // OK, price count.Имеет смысл.
```

``` cpp
// Плохо!
// Сокращения могут запутывающими или двусмысленными вне небольшой группы.
int wgc_connections; // Только ваша группа знает что означает.
int pc_reader; // Множество вещей может скрываться за сокращением "pc".
```

Никогда не сокращайте выбрасывая буквы:

``` cpp
int error_count; // Хорошо.
int error_cnt; // Плохо.
```

``` cpp
class MyClass {
 public:
  int CountFooErrors(const std::vector<Foo>& foos) {
    int n = 0;  // Чёткий смысл для небольшой области видимости
    for (const auto& foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  void DoSomethingImportant() {
    std::string fqdn = ...;  // Известная аббревиатура полного доменного имени
  }
 private:
  const int kMaxAllowedConnections = ...;  // Чёткий смысл для контекста
};
```

``` cpp
class MyClass {
 public:
  int CountFooErrors(const std::vector<Foo>& foos) {
    int total_number_of_foo_errors = 0;  // Слишком подробное имя для короткой функции
    for (int foo_index = 0; foo_index < foos.size(); ++foo_index) {  // Лучше использовать `i` 
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  void DoSomethingImportant() {
    int cstmr_id = ...;  // Сокращённое слово (удалены буквы)
  }
 private:
  const int kNum = ...;  // Для целого класса очень нечёткое имя
};
```

### Имена файлов.

Имена файлов должны использовать нижний регистр и могут включать подчеркивание (_) или дефис (-).Следуйте соглашениям вашего проекта.

Пример допустимых имен файлов:

 * my_useful_class.cc

 * my-useful-class.cc

 * myusefulclass.cc

С++ файлы должны иметь расширение .сс, а заголовочные файлы - расширение .h.

Не используйте имена уже существующих файлов в `/usr/include` , например db.h.

В целом, давайте очень специфичные имена файлам.Например, используйте `http_server_logs.h` вместо `logs.h` .Очень часто используются парные файлы, например `foo_bar.h` и `foo_bar.cc` , определяющие класс `FooBar` .

Встроенные функции должны быть в .h файле.Если ваши встроенные функции очень короткие, тогда их следует размещать в вашем .h файле.Хотя, если встроенные функции содержать много кода, они могут быть размещены в третьем файле заканчивающемся на inl.h.Класс с большим количеством встроенного кода может использовать три файла:

  + url_table.h // Объявление класса.

  + url_table.cc // Определение класса.

  + url_table-inl.h // Встроенные функции с большим числом кода.

### Имена типов

Имена типов начинаются с заглавной буквы и используют заглавную букву для каждого нового слова без подчеркивания: `MyExcitingClass` , `MyExcitingEnum` .

Имена всех типов - классов, структур, typedef-ов и перечислений - используют одно и тоже соглашение по наименованию .Имена типов следует начинать с заглавной буквы и использовать заглавную букву для каждого нового слова, без подчеркивания.Например:

``` cpp
// классы и структуры
class UrlTable { ... 
class UrlTableTester { ... 
struct UrlTableProperties { ... 

// typedefs
typedef hash_map<UrlTableProperties *, string> PropertiesMap; 

// enums
enum UrlTableErrors { ... 
```

### Имена Переменных

Имена переменных используют только нижний регистр с подчеркиванием между словами.Переменные члены классов завершаются подчеркиванием.К примеру:
`my_exciting_local_variable` , `my_exciting_member_variable_` .

#### Стандартные имена переменных

Пример:

``` cpp
string table_name; // OK - использует подчеркивание.
string tablename; // OK - все в нижнем регистре.
string tableName; // плохо - смешивание регистра.
``` 

#### Члены данных класса

Члены данных (также называемые переменные экземпляра или переменные члены) используют нижний регистр и возможно символ подчеркивания также как и имена нормальных переменных, но всегда заканчиваются символом подчеркивания.

``` cpp
string table_name_; // OK - подчеркивание в конце.
string tablename_; // OK.
```

#### Переменные структур

Члены данных в структурах следует называть также как и нормальные переменные без завершающего подчеркивания используемого для членов данных класса.

``` cpp
struct UrlTableProperties {
string name; 
int num_entries; 
}
```

*Смотри "Структуры или Классы" для дискуссии о том, когда использовать структуру вместо класса.*

#### Глобальные переменные

Нет особых требований для глобальных переменных, которые должны в любом случае использоваться редко, но если вы используете какое либо, тогда рассмотрите возможность использования префикса g_ или любого другого маркера для простого отличия их от локальных переменных.

### Имена констант.

Используйте k с последующими словами с заглавным регистром для первых букв: `kDaysInAWeek` .

Используйте k перед смешанным регистром: `kDaysInAWeek` .

Все константы времени компиляции, будь то объявленные локально, глобально или внутри класса, следуют слегка отличному от других переменных правилу именования.Используйте k c последующими словами с заглавным регистром для первых букв:

``` cpp
const int kDaysInAWeek = 7; 
```

### Имена Функций

Обыкновенные функции используют смешанный регистр: `MyExcitingFunction()` , `MyExcitingMethod()` .

Функции доступа соответствуют именам переменных: `my_exciting_member_variable()` , `set_my_exciting_member_variable()` .

### Регулярные Функции.

Функции следует начинать с заглавной буквы и использовать заглавную букву для каждого нового слова, без подчеркиваний:

``` cpp
AddTableEntry()
DeleteUrl()
```

### Функции доступа

Функции доступа (функции get и set) должны соответсвовать имени переменной, к которой они осуществляют доступ.Тут показывается выдержка класса с переменной класса num_entries_.

``` cpp
class MyClass {
public:
... 
int num_entries() const { return num_entries_; }
void set_num_entries(int num_entries) { num_entries_ = num_entries; }

private:
int num_entries_; 
}; 
```

Вы также можете использовать имена в нижнем регистре для других очень коротких встроенных функций.Например, если функция настолько "недорогая", что вы бы не кешировали ее значение при вызове в цикле, то использование нижнего регистра вполне допустимо.

### Имена пространств имен

Имена пространств имен записаны целиком в нижнем регистре, базируясь на имени проекта и, возможно, его структуры дерикторий: `google_awesome_project` .

*Смотрите "Пространство Имен" для обсуждения пространств имен и правил их именования.*

### Имена Перечислений

Перечисления следует называть либо как константы, либо как макросы: или `kEnumName` , или `ENUM_NAME` .

Предпочтительно элементы перечисления следует называть как константы.Хотя также допустимо именовать их как макросы.Имя самого перечисления, `UrlTableErrors` (и `AlternateUrlTableErrors` ), является типом, отсюда и смешанный регистр.

``` cpp
enum UrlTableErrors {
kOK = 0, 
kErrorOutOfMemory, 
kErrorMalformedInput, 
}; 

enum AlternateUrlTableErrors {
OK = 0, 
OUT_OF_MEMORY = 1, 
MALFORMED_INPUT = 2, 
}; 
```

До января 2009 было принято называть элементы перечисления подобно макросам.Это вызывало проблемы коллизий имен перечислений и макросов .Отсюда и перемена предпочтений в сторону по возможности константного стиля.

### Имена Макросов

Вы же не собираетесь в самом деле определять макрос, не так ли? Если все же собираетесь, тогда они выглядят как то так: `MY_MACRO_THAT_SCARES_SMALL_CHILDREN` .

Пожалуйста просмотрите описание макросов; в целом макросы не должны использоваться.Впрочем, если они абсолютно необходимы, они должны быть названы как члены перечисления полностью заглавными буквами с подчеркиваниями.

``` cpp
#define ROUND(x) ... 
#define PI_ROUNDED 3.0
```

### Исключения Правил Наименования.

Если вы даете имя чему то аналогичному существующей С или С++ сущности, тогда вы можете следовать существующей схеме наименований.

`bigopen()` - имя функции следующее форме open()

`uint` - похож на стандартный тип

`bigpos` - структура или класс следующее форме pos

`sparse_hash_map` STL-подобная сущность; следует правилам наименований STL сущностей.

`LONGLONG_MAX` - константа как INT_MAX

## Комментарии

Хотя и утомляют писать, комментарии абсолютно жизненно необходимы для поддержания читаемости нашего кода.Следующие правила описывают что вам следует комментировать и где.Но помните: хотя комментарии и очень важны, наилучший код самодокументируем.Гораздо лучше давать разумные имена типам и переменным, чем использовать запутанные имена, которые затем придется объяснять в комментариях.

При написании комментариев пишите для своей публики - следующего участника проекта, которому нужно будет разобраться в вашем коде.Будьте щедры - следующим участником можете быть вы!

### Стиль Комментария

Используйте либо `//` либо `/* */` синтаксис, но будьте последовательны.

Вы можете использовать либо `//` , либо `/* */` синтаксис, хотя `//` гораздо более употребим.Будьте последовательны в том, как вы комментируете и какой стиль используеться где.

### Файловые Комментарии.

Начинайте каждый файл с объявления авторских прав, с последующим описанием содержимого файла.

#### Официальное уведомление и Авторская строка.

Каждый файл должен содержать следующие пункты, по порядку: 

  + Объявление авторских прав (например, Copyright 2008 Google Inc.)

  + Штамп лицензии.Выберите подходящий штамп используемой в проекте лицензии (например Apache 2.0, BSD, LGPL, GPL) 
  + Авторская строка для определения оригинального автора файла.

Если вы вносите значимые изменения в файл, который первоначально был написан кем-то другим, то добавьте себя в список авторов.Это может быть весьма полезно, когда какой-либо участник имеет вопросы о файле, и ему необходимо узнать с кем связаться по этому поводу.

#### Содержимое файла

В каждом файле следует сверху, ниже списка авторов, размещать комментарий, описывающий содержимое файла.

В общем случае файл .h описывает объявленные в нём классы с обзором того, для чего и как они используются.В файле .cc следует размещать больше информации о деталях реализации или обсуждения сложных алгоритмов.Если вы полагаете, что детали реализации или обсуждения алгоритмов могут быть полезными кому-то, кто читает файл .h, то свободно размещайте их там, но в файле .cc сделайте упоминание о том, что документация находится в файле .h.

Не дублируйте комментарии сразу и в .cc, и в .h.Продублированные комментарии недопустимы.

### Комментарии к классу

К каждому определению класса следует добавлять сопроводительный комментарий, описывающий для чего и как его надлежит использовать.

``` cpp
// Выполняет итерации по содержимому GargantuanTable.Пример использования:
// GargantuanTable_Iterator* iter = table->NewIterator(); 
// for (iter->Seek("foo"); !iter->done(); iter->Next()) {
// process(iter->key(), iter->value()); 
// }
// delete iter; 
class GargantuanTable_Iterator {
... 
}; 
```

Если вы уже описали класс подробно в комментариях в начале файла, свободно пишите "Полное описание смотрите в комментариях в начале файла", но будьте уверены, что этот комментарий присутствует.

Документируйте особенности синхронизации, которые порождает класс, если таковые имеются.Если к экземпляру класса могут производиться обращения из нескольких потоков, уделите особенное внимание тому, чтобы задокументировать правила и инварианты, присутствующие при многопоточном использовании.

### Комментарии к функциям

Комментарии к объявлениям функции описывают их использование, комментарии к определению функций описывают их устройство.

#### Объявления функций

Каждому объявлению функции должны предшествовать комментарии объясняющие что функция делает и как ее использовать.Эти комментарии должны быть скорее описательные ("Открывает файл"), чем императивные ("Открыть файл"); комментарии описывают функцию, а не говорят функции что делать.В общем, эти комментарии не описывают как функция выполняет свою работу - это должно быть припасено для комментариев определения функции.

Следующее вещи имеет смысл указывать в комментариях к объявлению функции:

  + Входные и выходные параметры.

  + Для методов классов: запоминает ли объект ссылочные аргументы после окончания выполнения функции и освободит ли выделенную под них память или нет.

  + Выделяет ли функция память, которую вызывающая сторона должна освободить.

  + Могут ли какие либо из аргументов быть NULL.

  + Каковы ухудшения в производительности от того, как используется функция.

  + Является ли функция реентабельной.Каковы допущения при синхронизации?

Вот пример:

``` cpp
// Возвращает итератор для данной таблицы.На клиенте 
// лежит ответсвенность по удалению итератора после использования, 
// а также он не может использовать итератор после того, как объект 
// GargantuanTable, для которого итератор был создан, был удален.
//
// Изначально итератор позиционирован на начало таблицы.
//
// Этот метод эквивалентен следующему:
//    Iterator* iter = table->NewIterator(); 
//    iter->Seek(""); 
//    return iter; 
// Если вы собираетесь немедленно устанавливать итератор в другую позицию
// тогда будет быстрее использовать NewIterator()
// и тем самым избегать один лишний поиск.
Iterator* GetIterator() const; 
```

Хотя, не будьте излишне многословны и не константируйте очевидное.Обратите внимание в примере внизу, что совсем необязательно говорить "возвращает false в противном случае", поскольку это подразумевается.

``` cpp
// Возвращает true если таблица не может вместить больше данных.
bool IsTableFull(); 
```

При комментировании конструкторов и деструкторов помните, что человек читающий ваш код знает для чего они нужны, поэтому комментарии типа "уничтожить этот объект" не полезны.Документируйте что конструкторы делают со своими аргументами (например монополизируют ли они управление указателями), и какую очистку производит деструктор.Если это очевидно, тогда пропустите комментарий.Довольно часто деструкторы не имеют заголовочного комментария.

#### Определение функций.

Каждое определение функции должно содержать комментарий описывающий что функция делает и любые не очевидные детали реализации.Например, в определительном комментарии вы можете описать любые использованные трюки кодирования, дать обзор выполняемых шагов, или объяснить почему функция была реализована таким, а не другим приемлемым способом.К примеру, вы можете указать почему необходима локировка для первой части функции, но не для второй.

Обратите внимание, что вы не должны просто повторять комментарии из объявления функции в .h файле или где-то еще.Это нормально вкратце повторить что функция делает, но фокус должен быть смещен на то, как она это делает.

### Комментарии к переменным.

Как правило само имя переменной должно быть достаточно описательным чтобы объяснить для чего она используется.В некоторых случаях требуются дополнительные комментарии.

#### Члены данных класса.

Каждый член данных класса (также называемый переменная экземпляра или поле) должен иметь комментарий описывающий для чего он нужен.Если переменная может принимать сигнальные значения со специальным смыслом, такие как NULL или -1, документируйте это.Например:

``` cpp
private:
  // Содержит общее число записей в таблице.
  // Используется для проверки того, что лимит не превышен.-1 означает
  // что мы еще не знаем сколько записей в таблице
int num_total_entries_; 
```

#### Глобальные переменные

Как и с членами данных, все глобальные переменные следует снабжать комментариями описывающими чем они являются и для чего используются.Например: 

``` cpp
// Общее число тестов запускаемых в этом регрессивном тесте.
const int kNumTestCases = 6; 
``` 

### Комментарии реализации.

В вашей реализации вы должны комментировать запутанные, неочевидные, интересные или важные части вашего кода.

#### Члены Данных Класса

Блоки с запутанным или сложным кодом необходимо предварять комментариями. Пример:

``` cpp
// Делим результат на два, принимая во внимание, что x
// содержит перенос операции сложения
for (int i = 0; i < result->size(); i++) {
  x = (x << 8) + (*result)[i]; 
  (*result)[i] = x >> 1; 
  x &= 1; 
}
```

#### Комментарии к строкам

Кроме того, неочевидные строки должны иметь комментарий в конце.Эти комментарии следует отделять от кода 2 пробелами.Пример:

``` cpp
// Если у нас достаточно памяти, также mmap часть данных.
mmap_budget = max<int64>(0, mmap_budget - index_->length()); 
if (mmap_budget >= data_size_ && ! MmapData(mmap_chunk_bytes, mlock))
return; // Ошибка уже записана.
```

Заметьте, что здесь есть и комментарий, описывающий, что делает код, и комментарий, упоминающий, что когда функция завершается, ошибка уже записана.

Если у вас есть несколько комментариев к последовательным строкам, часто может быть более читабельным, если их выстроить.

``` cpp
DoSomething(); // Комментируйте тут так, чтобы комментарии выравнивались
DoSomethingElseThatIsLonger();  // Комментируйте здесь, так что тут два пробела 
// между кодом и комментарием.
{ // Один пробел допустим при открытии новой области видимости, 
 // таким образом комментарий выравнен с последующими комментариями и кодом.
DoSomethingElse();  // Два пробела перед комментариями в обычном случае.
}
```

### NULL, true/false, 1, 2, 3... 

При передаче в функцию NULL, boolean или символьных целых значений следует их комментировать или писать само-документирующийся код используя константы.Например сравните:

``` cpp
// Что означают все эти аргументы??
bool success = CalculateSomething(interesting_value, 10, false, NULL); 
```

вместо:

``` cpp
bool success = CalculateSomething(interesting_value, 
                                  10, // базовое значение по умолчанию
                                  false, // Функция вызывается не в первый раз.
                                  NULL); // Без возвратной функции .
```

Или, в качестве альтернативы, используя константы или само-описывающие переменные:

``` cpp
const int kDefaultBaseValue = 10; 
const bool kFirstTimeCalling = false; 
Callback *null_callback = NULL; 
bool success = CalculateSomething(interesting_value, kDefaultBaseValue,
                                  kFirstTimeCalling, null_callback); 
```

### Что делать нельзя

Не объясняйте очевидное.В частности, не нужно объяснять вещи, очевидные для человека, знающего C++.Вместо этого, можно описать зачем этот код делает так (или вообще сделайте код само-описываемым).

Сравним:

``` cpp
// Ищём элемент в векторе.  <-- Плохо: очевидно же!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
```

С этим:

``` cpp
// Обрабатывает (Process) "element" пока есть хоть один
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
```

Само-описывающий код вообще не нуждается в комментариях.Комментарий на код выше может быть вообще очевидным (и не нужным):

``` cpp
if (! IsAlreadyProcessed (element)) { 
  Process (element); 
}
```

### Пунктуация, Орфография, Грамматика

Обратите внимание на пунктуацию, орфографию и грамматику, легче читать хорошо написанные комментарии, чем плохо написанные.

Комментарии, как правило, должны быть написаны как законченные предложения с соответствующими прописными буквами и точкой в конце.Короткие комментарии, такие как комментарии в конце строки кода, иногда могут быть менее формальные, но Вы должны соответствовать вашему стилю.Законченные предложения более читабельные, и они предоставляют гарантию, что комментарий закончен и мысль тоже.

Хотя это очень расстраивает, когда при просмотре кода вам указывают, что вместо запятой должна быть использована точка с запятой, тем не менее очень важно, чтобы исходный код поддерживал высокий уровень ясности и читабельности.Правильная пунктуация, правописание и грамматика помогают достичь этой цели.

### Комментарии TODO 

Используйте TODO [сделать в будущем] комментарии для временного кода, кратковременного или допустимого, но не идеального решения.

TODO комментарии должный включать строку TODO заглавными буквами с последующим вашим именем, почтовым адресом или другим идентификатором в скобках.Основной задачей является использование согласованного TODO формата с возможностью поиска человека написавшего этот комментарий (который может предоставить подробности по требованию). TODO не является обязательством перед самим собой исправить код.

``` cpp
// TODO(kl@gmail.com): Используйте "*" для объединения.
// TODO(Zeke) Изменить для связывания.
// TODO(bug 12345): удалить фунционал "Последний посетитель".
```

Если ваш TODO имеет форму "В будущем сделать то-то", тогда обязательно либо укажите конкретную дату ("Исправить к ноябрю 2005"), либо конкретное событие ("Убрать этот код после того, как клиент сможет обрабатывать XML ответы").

## Форматирование

Стиль кодирования и форматирования довольно произволен, однако проект гораздо легче сопровождать, если каждый использует тот же стиль.Некоторые могут не согласиться с каждым аспектом правил форматирования, и отдельные правила могут потребовать определённого привыкания, но важно, чтобы все участники проекта следовали стилистическим правилам так, чтобы все они могли легко читать и понимать код каждого.

Чтобы помочь Вам форматировать код правильно, мы создали файл параметров настройки для emacs.

### Длина Строки

Каждая строка текста в вашем коде не должна превышать 80 символов в длину.

Мы признаем, что это правило спорно, но так много существующего кода уже придерживается его, и мы считаем, что последовательность важна.

Доводы "за": Те, кто одобряет это правило, утверждают, что грубо вынуждать их изменять размеры своего окна и нет никакой потребности ни в чем длиннее.Некоторые люди привыкли иметь несколько окон кода бок о бок, и, следовательно, не имеют возможности для расширения своего окна.Люди установили для себя определенный максимум ширины окна, и 80 колонок стало традиционным стандартом.Зачем это менять?

Доводы "против": Сторонники изменения утверждают, что более широкая строка может сделать код более читаемым.Предел на 80 столбцов - истощенный возврат к универсальным ЭВМ 1960-ых; у современного оборудования есть широкие экраны, которые могут легко показать более длинные строки.

#### Решение:

80 символов — максимум.

#### Исключение: 

Если строка комментария содержит пример команды или URL длиннее 80 символов, то строка может быть длиннее 80 символов, для простоты вырезания и вставки.

#### Исключение: 

Выражение `#include` с длинным путем может превысить 80 столбцов.Пытайтесь избегать тех ситуаций, где это является необходимым.

### Пробелы или табуляция?

Используйте только пробелы, по 2 на уровень отступа.

Мы используем пробелы для отступа.Не используйте табуляцию в вашем коде.Вам следует настроить свой редактор на добавление пробелов при нажатии клавиши табуляции.

### Объявления и определения функций

Тип возвращаемого значения и параметры, если они умещаются, должны быть на одной строке с именем функции.

Функции выглядят следующим образом:

``` cpp
ReturnType ClassName:: FunctionName(Type par_name1, Type par_name2) {
  DoSomething(); 
... 
}
```

Если у вас слишком много текста, чтобы поместить на одной строке:

``` cpp
ReturnType ClassName:: ReallyLongFunctionName(Type par_name1, Type par_name2, 
                                              Type par_name3) {
  DoSomething(); 
  ... 
}
```

или если вы не можете вместить даже первый параметр:

``` cpp
ReturnType LongClassName:: ReallyReallyReallyLongFunctionName(
    Type par_name1, // отступ 4 пробела
    Type par_name2, 
    Type par_name3) {
  DoSomething(); // отступ 2 пробела
  ... 
}
```

Несколько пунктов на заметку:

  + Возвращаемый тип всегда находится на той же самой строке где и имя функции.

  + Открывающая скобка всегда находится на той же самой строке где и имя функции.

  + Никогда нет пробелов между именем функции и открывающей скобкой.

  + Никогда нет пробелов между круглыми скобками и параметрами.

  + Открывающая фигурная скобка всегда в конце той же самой строки где последний параметр.

  + Закрывающая фигурная скобка или на последней строке отдельно или (если другой стиль кодирования разрешен) на той же самой строке где открывающая фигурная скобка.

  + Должен быть пробел между закрывающей круглой скобкой и открывающей фигурной скобкой.

  + Все параметры нужно назвать, с идентичными названиями в объявлении и реализации.

  + Все параметры должны быть согласованы, если это возможно.

  + Стандартный отступ- 2 пробела.

  + Упакованные параметры имеют отступ в 4 пробела.

Если функция - константна, ключевое слово const должно быть на строке с последним параметром:

``` cpp
// Все ключи этой функции вписывается в одну строку
ReturnType FunctionName(Type par) const {
  ... 
}
```

``` cpp
// Ключи этой функции требуют несколько строк, но
// ключевое слово const находится на строке с последним параметром.
ReturnType ReallyLongFunctionName(Type par1, 
                                  Type par2) const {
... 
}
```

Если какие-то параметры не используются, закомментируйте имя переменной в определении функции:

``` cpp
// Всегда именуйте параметры в интерфейсе.
class Shape {
  public:
    virtual void Rotate(double radians) = 0; 
}

// Всегда именуйте параметры в объявлении.
class Circle : public Shape {
  public:
    virtual void Rotate(double radians); 
}
// Закомментируйте неиспользуемые именованные параметры в определениях.
void Circle:: Rotate(double /*radians*/) {}
```

``` cpp
// Плохо - если кто-то захочет воспользоваться позднее и не поймет, что
// означает переменная.
void Circle:: Rotate(double) {}
```

### Лямбда-выражения

Отформатируйте параметры и тела, как для любой другой функции, и захватывайте списки, как и другие разделенные запятыми списки.

Для захвата по ссылке не оставляйте пробел между амперсандом (&) и именем переменной.

``` cpp
int x = 0; 
auto x_plus_n = [& x](int n) -> int {return x + n; }
Короткие лямбды могут быть записаны в виде аргументов функции.

std::set<int> blacklist = {7, 8, 9}; 
std::vector<int> digits = {3, 9, 1, 8, 4, 7, 1}; 
digits.erase(std::remove_if (digits.begin(), digits.end(), [& blacklist](int i) { 
               return blacklist.find (i)! = blacklist.end (); 
             }), digits.end ());
```

### Литералы с плавающей точкой

Литералы с плавающей точкой всегда должны иметь основную точку с цифрами с обеих сторон, даже если они используют экспоненциальную запись.Читаемость улучшается, если все литералы с плавающей точкой принимают эту знакомую форму, поскольку это помогает гарантировать, что они не будут приняты за целочисленные литералы, и что `E/` eэкспоненциальной нотации не будет ошибочно принята за шестнадцатеричное число.Можно инициализировать переменную с плавающей точкой целочисленным литералом (при условии, что тип переменной может точно представлять это целое число), но обратите внимание, что число в экспоненциальной нотации никогда не является целочисленным литералом.

``` cpp
float f = 1.f; 
long double ld = -.5L; 
double d = 1248e6;
```

``` cpp
float f = 1.0f; 
float f2 = 1; // Также хорошо 
long double ld = -0.5L; 
double d = 1248,0e6;
```

### Вызовы функций

На одной линии, если умещаются, в противном случае, переносите аргументы в скобках.

Вызовы функций имеют следующий формат:

``` cpp
bool retval = DoSomething(argument1, argument2, argument3); 
```

Если аргументы не умещаются на одной строке, их следует разделять на несколько строк.Каждая следующая строка должна быть выровнена по первому аргументу.Не добавляйте пробелы после открывающей скобки или перед закрывающей.

``` cpp
bool retval = DoSomething(averyveryveryverylongargument1, 
                           argument2, argument3); 
```

Если функция имеет много аргументов, подумайте о том, чтобы разместить каждый на отдельной линии, если это улучшает читаемость кода:

``` cpp
bool retval = DoSomething(argument1, 
                          argument2,
                          argument3,  
                          argument4); 
```

Если сигнатура функции настолько длинная, что не умещается на максимальной длине строки, вы можете разместить все аргументы на отдельных строках:

``` cpp
if (... ) {
  ... 
  ... 
  if (... ) {

  DoSomethingThatRequiresALongFunctionName(
      very_long_argument1, // отступ в 4 пробела
      argument2, 
      argument3, 
      argument4); 
  }
```

### Условные выражения

Не стоит ставить пробелы внутри скобок.Ключевое слово else должно быть на новой строке.

Есть два приемлемых формата для основных условных выражений.Один включает пробелы между скобками и условием, а другой — нет.

Наиболее обычная форма — без пробелов.Хороши обе, но будьте последовательным.Если вы изменяете файл, используйте тот формат, который уже используется.Если вы пишете новый код, применяйте формат, который используют другие файлы в директории или проекте.Если сомневаетесь или не имеете личных предпочтений, то не добавляйте пробелы.

``` cpp
if (condition) { // внутри скобок нет пробелов
  ... // отступ в 2 пробела.
} else { // Слово else идёт на той же строке, на которой стоит закрывающая скобка.
  ... 
}
```

Если нравится, можете добавлять пробелы внутри скобок:

``` cpp
if ( condition ) { // пробелы внутри скобок - редкость
  ... // отступ в 2 пробела.
} else { // Слово else идёт на той же строке, на которой стоит закрывающая скобка.
  ... 
}
```

Заметьте, что во всех случаях вы должны ставить пробелы между словом if и открывающей скобкой.Также вы должны ставить пробел между закрывающей скобкой и фигурной скобкой, если таковую используете.

``` cpp
if(condition) // Плохо - нет пробела после IF.
if (condition){ // Плохо - нет пробела перед {.
if(condition){ // Плохо вдвойне.
if (condition) { // Хорошо - верные пробелы после IF и перед {.
```

Короткие условные выражения можно писать на одной строке, если это улучшает читаемость.Вы можете использовать это лишь тогда, когда строка не длинна, и в выражении не используется `else` .

``` cpp
if (x == kFoo) return new Foo(); 
if (x == kBar) return new Bar(); 
```

Это непозволительно, если в выражении присутствует else:

``` cpp
// Нельзя - выражение IF на одной строке в то время, как присутствует ELSE
if (x) DoThis(); 
else DoThat(); 
```

В целом, фигурные скобки не являются обязательными для однострочных блоков, но они разрешены, если они вам нравятся; условное выражение или операторы цикла со сложными условиями становятся более читаемыми с фигурны скобами.Некоторые проекты требуют, чтобы `if` всегда имел сопроводительную скобу.

``` cpp
if (condition)
  DoSomething(); // отступ - 2 пробела.

if (condition) {
  DoSomething(); // отступ - 2 пробела.
}
```

Однако, если одна часть оператора `if-else` использует фигурные скобы, другая часть, тоже должна:

``` cpp
// Не разрешено - фигурные скобки на IF, но не на ELSE
if (condition) {
  foo; 
} else
  bar; 

// Не разрешено - фигурные скобки на ELSE, но не на IF
if (condition)
  foo; 
else {
  bar; 
}
```

``` cpp
// Фигурные скобки вокруг IF и ELSE требуется, поскольку
// один из блоков используются скобки.

if (condition) {
  foo; 
} else {
  bar; 
}
```

### Циклы и Операторы Выбора

Оператор `Switch` может использовать скобки для блоков.Пустые тела цикла должны использовать {}.

`case` блоки в `switch` выражениях могут иметь или не иметь фигурные скобки, в зависимости от ваших предпочтений.Если вы используете фигурные скобки, тогда они должны быть использованы так, как показано ниже.

Если условное выражение в `switch` выражении не основано на перечислимом значении, тогда вы обязаны использовать `default` (в случае перечислимого значения компилятор предупредит вас если какие либо значения не обрабатывается).Если `default` никогда не должен выполняться, тогда просто проверьте это:

``` cpp
switch (var) {
  case 0: { // вставить два пробела
    ... // вставить 4 пробела
    break; 
  }
  case 1: {
    ... 
    break; 
  }
  default: {
    assert(false); 
  }
}
```

Пустой цикл должен использовать `{}` либо `continue` , но не точку с запятой.

``` cpp
while (condition) {
  // Повторить тест до тех пор, пока он вернет результат
}
for (int i = 0; i < kSomeNumber; ++i) {} // Хорошо - пустое тело цикла.
while (condition) continue; // Хорошо - continue означает пустой цикл.
```

``` cpp
while (condition); // Плохо - выглядит как часть цикла do/while.
```

### Выражения с указателями и ссылками.

Не используйте пробел около точки или угловой стрелки.Операции с указателями не должны заканчиваться пробелами.

Ниже приведены примеры правильно сформированных выражений с указателями и ссылками:

``` cpp
x = *p; 
p = &x; 
x = r.y; 
x = r->y; 
```

Обратите внимание что:

  + Отсутствуют пробелы вокруг "." или "->" при доступе к члену.

  + Операторы указателей не имеют пробелов после * или &.

При объявлении указателей переменных или аргументов вы можете размещать символ * примыкающим или к типу, или к имени переменной:

``` cpp
// Так допустимо - предворяются пробелом
char *c; 
const string &str; 

// Так допустимо - последующий пробел 
char* c; // но помните писать "char* c, *d, *e, ... ; "!
const string& str; 
```

``` cpp
char * c; // Плохо: пробелы с обеих сторон *
const string & str; // Плохо: пробелы с обеих сторон &
```

Следует быть последовательным в каждом файле, так что, при модификации существующего файла, используйте в нем выбранный стиль.

### Логические Выражения

Если ваше логическое выражение длиннее страндрартной длины строки, то будьте последовательны в том, как вы разбиваете ее на строки.

В данном примере логический оператор "И" всегда в конце строк:

``` cpp
if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another & last_one) {
  ... 
}
```

Обратите внимание оба логических "И" && размещаются в конце строки.Без колебаний используйте дополнительные скобки на свое усмотрение, поскольку они, при правильном употреблении, могут быть весьма полезны в повышении читаемости кода.

### Возвращаемые Значения.

Не заключайте возвращаемое выражение в скобки.

Возвращаемые значения не должны иметь скобок:

``` cpp
return x; // а не return(x); 
return (some_long_condition &&
        another_condition); // OK to make a complex expression more readable
```

### Инициализация Переменных и Массивов.

Ваш выбор =, {} или ().

Вы можете выбирать между =, {} или (); все нижеследующие примеры верны:

``` cpp
int x = 3; 
int x(3); 
int x{3};
std::string name("Some Name"); 
std::string name = "Some Name"; 
std::string name{"Some Name"};
```

### Директивы Препроцессора.

Не стоит форматировать директивы препроцессора отступом - они всегда должны начинаться с начала строки.

Даже если директивы препроцессора находятся внутри блока с отступом они должны начинаться с начала строки.

``` cpp
// Хорошо - директивы в начале строки
  if (lopsided_score) {
#if DISASTER_PENDING // Правильно - начинается с начала строки
    DropEverything(); 
#endif
    BackToNormal(); 
}
```

``` cpp
// Плохо отформатированные директивы
if (lopsided_score) {
  #if DISASTER_PENDING // Неверно! "#if" должно быть в начале строки
  DropEverything(); 
  #endif // Неверно! Не делайте отступов перед "#endif"
  BackToNormal(); 
}
```

### Формат Класса

Секции размещаются в порядке `public` , `protected` и `private` , каждая с отступом в один пробел.

Основной формат объявления класса (без использования комментариев, *см."Комментарии к классу"* для обсуждения того, какие комментарии необходимы):

``` cpp
class MyClass : public OtherClass {
 public: // Обратите внимание на отступ в 1 пробел!
  MyClass(); // Стандартный 2-х пробельный отступ.
  explicit MyClass(int var); 
  ~MyClass() {}

  void SomeFunction(); 
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction(); 

  int some_var_; 
  int some_other_var_; 

  DISALLOW_COPY_AND_ASSIGN(MyClass); 
}; 
```

На что обратить внимание:

  + Имя любого базового класса должно быть в той же строке с именем подкласса и подвержено ограничению 80-ти символов на строку.

  + Ключевые слова public:, protected: и private: должны иметь отступ в один пробел.

  + За исключением первого ключевого слова они должны отделяться пустой строкой.Это правило необязательно для маленьких классов.

  + Не вставляйте пустую строку после этих ключевых слов.

  + public секция должна быть первой, затем следует protected и затем private.

  + Смотрите *"Порядок Объявлений"* для правил упорядочения объявлений в этих секциях.

### Инициализирующие Списки

Инициализирующие списки конструктора могут быть на одной строке или с последующими строками использующими отступ в четыре пробела.

Существует два допустимых формата для инициализирующих списков:

``` cpp
// Когда все помещается в одну строку:
MyClass:: MyClass(int var) : some_var_(var), some_other_var_(var + 1) {}
```

или

``` cpp
// Когда требуются дополнительные строки вставляйте 4-е пробела, размещая
// двоеточие в первой инициализирующей строке:
MyClass:: MyClass(int var)
    : some_var_(var), // отступ в 4 пробела
    some_other_var_(var + 1) { // выровнить
  ...
  DoSomething(); 
  ... 
}
```

### Форматирование пространств имен

Содержимое пространства имен не требует отступа.

Пространства имен не добавляют еще один уровень отступа.Например:

``` cpp
namespace {
void foo() { // Правильно.Нет дополнительного отступа внутри пространства имени.
  ... 
}
} // namespace
```

Не используйте отступ внутри пространства имен:

``` cpp
namespace {
// Неправильно.Неправомерно использован отступ.
 void foo() {
  ... 
}
} // namespace
```

### Горизонтальные пробелы

Использование горизонтальных пробелов зависит от места.Никогда не размещайте пробелы в конце строки.

#### Общее

``` cpp
void f(bool b) { // Открывающие скобки всегда должны иметь пробел перед ними.
  ... 
int i = 0; // Точка с запятой обычно не имеет пробела перед ней.
int x[] = { 0 }; // Пробелы внутри скобок для инициализации массива
int x[] = {0}; // необязательны.Если вы используете их, размещайте их на обоих сторонах!

// Пробелы вокруг двоеточия при наследовании и в инициализирующих списках.
class Foo : public Bar {
 public:
  // В встроенных функциях размещайте пробелы между скобками
  // и собственно кодом функции
  Foo(int b) : Bar(), baz_(b) {} // В пустых функциях пробел не нужен.
  void Reset() { baz_ = 0; } // Пробелы между скобками и реализацией.
  ... 
```

Добавление пробелов в конце строки, также как и их удаление, может добавить работы для других редактирующих этот же файл при объединении кода.Поэтому: не используйте пробелы в конце строки.Удаляйте их, если вы уже редактируете эту строку, или делайте это в отдельной очистительной редакции (желательно когда никто не работает с этим файлом).

#### Циклы и условия

``` cpp
if (b) { // Пробел после if
} else { // Пробелы вокруг else
}
while (test) {} // Нет пробела между фигурными скобками
switch (i) {
for (int i = 0; i < 5; ++i) {
switch ( i ) { // Циклы и условия могут содержать пробелы
if ( test ) { // внутри круглых скобок в редких случаях.Будьте последовательны.
for ( int i = 0; i < 5; ++i ) {
for ( ; i < 5 ; ++i) { // Циклы for всегда используют пробел после
  ... // точки с запятой, и могут иметь пробел перед точкой с запятой.
switch (i) {
  case 1: // Нет пробела перед двоеточием в switch case.
  ... 
  case 2: break; // Используйте пробел после двоеточия если за ним идет код.
```

#### Операторы

``` cpp
// Операторы присвоения всегда окружены пробелами
x = 0; 
// Никаких пробелов разбивающих унарные операторы их аргументы.
x = -5; 
++x;
if (x && !y)
  ... 
// Бинарные операторы обычно окружены пробелами, но допустимо убирать пробелы
// между множителями. Круглы скобки не должны иметь пробелов вокруг них.
v = w * x + y / z; 
v = w*x + y/z; 
v = w * (x + z); 
``` 

#### Шаблоны и приведение типов.

``` cpp
// Никаких пробелов внутри угловых  скобок (< и >), перед <, или между 
// >( при приведении типа.
vector<string> x; 
y = static_cast<char*>(x); 

// Пробелы между типом и указателем допустимы, но будьте последовательны.
vector<char *> x; 

 // C++ требует пробела в > >. Возможно вставлять пробел в < < для симметрии.
set<list<string> > x;
set< list<string> > x;  
```

### Вертикальные пробелы

Минимизируйте использование вертикальных пробелов.

Этот код показывает суть.Не используйте пустые строки если этого не требуется.Не отделяйте функции больше чем двумя пустыми строками, так-же не стоит начинать и заканчивать функции пустой строкой.Пустые строки в теле функций так-же не желательны.

Основной принцип - чем больше кода умещается на экране, тем легче его читать и понимать смысл его выполнения.Конечно, читаемость кода может от этого пострадать, поэтому пользуйтесь здравым смыслом.Но в целом, старайтесь уменьшить количество пустых строк.

Не начинайте и заканчивайте функции пустыми строками

``` cpp
void Function() {

// Ненужные строки в начале и в конце

}
```

Не следует начинать и заканчивать блок пустыми строками

``` cpp
while (condition) {
// Не нужная строка в конце

}
if (condition) {

// Не нужная строка в начале
}
// Можно добавлять пустые строки между if-else блоками
if (condition) {

// Некоторые строки кода слишком маленькие, чтобы их можно было перенести в другую функцию, 
// заканчиваются пустой строкой

} else {

// следующий блок кода

}
``` 

## Исключения из правил

Правила написания кода описанные выше являеются обязательными.Тем не менее как и все правила, тоже содержат исключения, описанные ниже.

### Существующий код, написанный не по правилам

Вы можете не следовать правилам, если код не соответствует стилю описанном в данном руководстве.

Если вам нужно править код, который был написан не по правилам этого руководства, вы можете не следовать этим правилам, чтобы сохранить целостность кода.Если вы сомневаетесь, спросите автора оригинального кода или человека, который отвечает за этот код.Запомните, что целостность кода подразумевает и локальную целостность.

### Код для Windows

Программисты, пишущие для Windows, выработали свой собственный набор соглашений кодирования, производный главным образом от соглашений в заголовочных файлах Windows и другом коде Microsoft.Мы хотим упростить понимание кода для всех, потому используем отдельный набор руководств для всех программистов C++, пишущих на этой платформе.

Стоит повторить несколько правил, которые вы, возможно, забыли, если привыкли к общепринятому в Windows стилю.

  + Не используйте венгерскую нотацию (например, называя целочисленную переменную `iNum` ).Используйте соглашения именования Google, включая расширение .cc для файлов с исходным кодом.

  + Windows определяет множество собственных синонимов для базовых типов, такие как `DWORD` , `HANDLE` и т.п.Они идеально применимы и поощряются, когда используются в вызовах функций Windows API.Даже в этих условия, придерживайтесь базовых типов C++ настолько близко, насколько можете.К примеру, используйте const TCHAR * вместо LPCTSTR.

  + При компиляции с помощью Microsoft Visual C++ установите 3-ий уровень предупреждений компилятора или выше и расценивайте все предупреждения как ошибки.

  + Не используйте `#pragma once;` вместо неё применяйте стандартные предохранители Google.Путь в предохранителях должен быть относительным к вершине дерева проекта.

  + Фактически, не используйте любые нестандартные расширения, вроде `#pragma` и `__declspec` , если они не являются безусловно необходимыми.Использование `__declspec(dllimport)` и `__declspec(dllexport)` позволяется; в любом случае, вы должны применять их посредством макросов, таких, как `DLLIMPORT` и `DLLEXPORT` , чтобы любой смог просто отключить расширения, если публикует код.

Так или иначе, есть несколько правил, которые приходится периодически игнорировать в Windows:

  + Обычно, мы запрещаем реализацию множественного наследования, но это необходимо при использовании COM и некоторых классов ATL/WTL.Вы можете использовать множественное наследование, чтобы реализовать классы и интерфейсы COM или ATL/WTL.

  + Хотя вам не следует использовать исключения в вашем собственном коде, они значительно используются в ATL и некоторых реализациях STL, включая ту, что поставляется вместе с Visual C++.При использовании ATL вам следует определить `_ATL_NO_EXCEPTIONS` , чтобы отключить исключения.Следует узнать, возможно ли также отключить исключения в вашей STL; если нет, то разрешение исключений в компиляторе позволяется (заметьте, что это лишь для того, чтобы скомпилировать STL; самостоятельно писать обработку исключений в коде всё равно недопустимо).

  + Традиционный способ работы с предварительно скомпилированными заголовками это включение заголовочного файла, обычно с названием вроде `StdAfx.h` или `precompile.h` , в самом верху каждого файла с исходным кодом.Дабы упростить внедрение вашего кода в другие проекты, избегайте явного включения этого файла (за исключением `precompile.cc` ) и используйте опцию компилятора `/FI` для автоматического включения предварительно скомпилированного заголовка.

  + Заголовки ресурсов, обычно именуемые `resource.h` и содержащие лишь макросы, не нужно приводить в соответствие с этими стилистическими правилами.

## Напутственные слова

Будьте последовательным и не забывайте о здравом смысле.

Если редактируете код, уделите несколько минут на то, чтобы взглянуть на окружающий код и определить его стиль.Если используются пробелы вокруг скобок, вам следует тоже.сли комментарии содержат маленькие квадраты или звёздочки вокруг, сделайте свои комментарии также с маленькими квадратами или звёздочками вокруг.

Смысл наличия стилистических правил в том, чтобы иметь привычную терминологию кодирования, чтобы люди могли сосредоточиться на том, что они говорят, а не на том, как они это делают.Здесь мы представляем всеобщие стилистические правила, это терминология .Но частный стиль также важен.Если код, что вы добавляете в файл, выглядит радикально отличающимся от существующего окружающего кода, то нарушение последовательности собьёт читателей с ритма, когда они соберутся прочесть его.Пытайтесь этого избежать.

